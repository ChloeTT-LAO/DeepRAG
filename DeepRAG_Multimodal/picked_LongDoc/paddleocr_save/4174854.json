{
    "Page_1": "Introduction to the LonWoRks? Platform\nRevision 2\n078-0183-01B",
    "Page_2": "Echelon, LON, LonWorks, LonMark, NodeBuilder, ,LonTalk, Neuron, 3120, 3150,\nLNS, i.LON, , ShortS tack, LonMaker, the Echelon logo, and are trademarks of\nEchelon Corporation registered in the United States and other countries. LonS upport,\ntrademarks of Echelon Corporation. Other trademarks belong to their respective\nholders.\nNeuron Chips, Smart Transceivers, and other OEM Products were not designed for\nuse in equipment or systems which involve danger to human health or safety or a risk\nof property damage and Echelon assumes no responsibility or liability for use of the\nNeuron Chips in such applications.\nParts manufactured by vendors other than Echelon and referenced in this document\nhave been described for illustrative purposes only, and may not have been tested by\nEchelon. It is the responsibility of the customer to determine the suitability of these\nparts for each application.\nECHELON MAKES ANDYOU RECEIVE NO WARRANTIES OR CONDITIONS,\nEXPRESS,IMPLIED,STATUTORYORINANYCOMMUNICATIONWITHYOU,\nAND ECHELON SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF\nrecording, or otherwise, without the prior written permission of E chelon Corporation.\nPrinted in the United States of America.\nCopyright @1999-2009 by Echelon Corporation.\nE chelon Corporation\nwww.echelon.com\n2",
    "Page_3": "Contents\nContents...\n.3\nChapter 1.\nIntroduction.\n5\nOverview....\n...6\nThe Market Value of Networked Control Systems .\n.7\nLONWoRKS Networks..\n.9\nImplementing a Control Network.\n10\n Cost-Effective Network Wiring...\n10\nCompatible Devices .\n11\nEffective System Design\n.11\nStandard Network Management.\n.11\nStandard Network Tools.\n11\nStandard Device Configuration....\n.12\n Standard IP Support .\n12\nGetting More Information\n.12\nChapter 2.\nPlatform Components\n14\n Building a Platform\n.15\nSmart Transceivers.\n.15\n Development Tools.\n.16\nRouters.\n.17\nNetwork Interfaces\n..18\nSmart Servers\n.18\nNetwork Management .\n.18\nNetwork Tools\n.21\n LonMaker Integration Tool\n.22\nLonScanner Protocol Analyzer ..\n.23\nChapter 3.\nThe Control Network Protocol\n.25\nISO/IEC 14908-1 Control Network Protocol\n26\nCNP Layers..\n.27\nCNP Data Transmission.\n.29\nCNP Limits ..\nLayer . Physical Layer ......\nChannel Types.\n.31\n TP/FT-10 Free Topology Twisted Pair.\n.32\n PL-20 Power Line...\n...39\nLayer 2Link Layer....\nMedia Access...\nPriority ...\nFrame Format.\n.45\nLayer-2 Performance.\n.47\nLayer 3—Network Layer\n.50\n Naming and Addressing..\n.50\nAddressing Format. ...\n.55\nAddress Table.\n.55\nRouters..\n.56\nContents\n3",
    "Page_4": "Physical Layer Repeaters .\n58\nDatagram Format....\n.58\nLayer 4Transport Layer....\nMessage Services....\n.60\nCNP Timers\n.61\nTransport Packet Format ..\n.63\nLayer ..Session Layer..........\n.64\nRequest/Response ..\n.65\nAuthentication.\n.65\nSession.  Packet Format....\nLayer 6.Presentation Layer....\n.69\n...70\n Presentation Packet .\n...77\n Layer 7—-Application Layer ...\nApplication Configuration.....\n.80\nApplication Specification\n.80\nAppendix A.\nLayer 1 and 2 Advanced Topics...\n84\nLayer 1 Neuron Communications Interface...\n.85\nLayer 2 Advanced Topics...\n.90\nInterpacket Gap...\n.90\nCollision Detection .\n.93\nCollision Resolution.....\n....94\nOscillator Accuracy..\nPreamble Length.\nContents",
    "Page_5": "Chapter 1.\nIntroduction\nThis chapter presents an introduction to the LoNWoRKS\nplatform and LoNWoRKS networks, and provides an\noverview of how to implement a control network.\nIntroduction",
    "Page_6": "Overview\nAcross a broad range of products and systems-from factory automation systems to\nbuilding controls to embedded machine controls to consumer electronics-there is a\ntrend away from centralized control systems. Manufacturers are building products\nbased on open standard control network architectures that feature intelligent\ndistributed control using a standard communication protocol and readily available\noff-the-shelf low-cost firmware and transceivers for communication. These open\nsolutions ensure reliability, flexibility, lower cost, and faster development, and\n provide enhanced energy monitoring and control. This trend is made possible with\nthe emergence of control networks the low-cost alternative to centralized control\nand proprietary communication systems.\n In a centralized control system, remote sensors provided feedback to a\nmicrocontroller, programmable logic controller, or other proprietary controller that in\nturn sends control impulses to relays and other actuators. Each centralized control\nsystem has its own unique input/output and processing requirements. Large.\ncomplex control systems may be partitioned into two or more centralized systems\nwhose controllers must communicate continuously. These controllers and their\nattached systems act as islands of automation, with artificially limited\ncommunication between the islands. Whether partitioned or not, these control\nsystem are expensive to develop, costly to install, and difficult to expand.\nIn a control network, intelligent control devices communicate using a common\nprotocol. Each device in the control network contains embedded intelligence that\nimplements the common protocol and performs control functions. In addition, each\ndevice includes a communication transceiver that couples the device with the\ncommunications medium.\nDevices in a control network may each perform a simple task, or may be more\ncomplex devices that perform a multitude of tasks. Devices may be simple sensors\nand actuators such as proximity sensors, switches, motion detectors, or relays.\n Devices may also be complex supervisory control and data acquisition systems that\nmonitor other devices on the network and provide supervisory control of the entire\nsystem. Although individual devices may execute simple tasks, the system may\nperform a complex control application, such as running a manufacturing line or\nautomating a building.\n Control networks require a diferent type of networking platform than data\nprocessing or office automation applications. Control networks are distinguished by\nsmall messages that are frequently transmitted and that require high reliability with\nlow overhead.\nFor example, a process control system may have a number of pressure and\ncontrollers. Each heater controller uses the input to set the power output to the\nheating elements. This system does not move megabytes of data, but does require\nreliable delivery of the temperature and pressure updates to ensure correct\noperation.\nMany manufacturers understand the benefits of control networks and have\nattempted to solve these problems by creating their own control network platform.\nManufacturers who develop proprietary control networks have a similar problem to\nIntroduction\n6",
    "Page_7": "manufacturers who develop communicating centralized controls systems-they find\nthat most of their engineering effort is spent implementing and testing\ncommunications systems, rather than developing control features and applications\nthemselves. Ultimately, the high cost of this design approach has limited the market\nfor control systems.\nWith thousands of application developers and millions of devices installed worldwide,\nthe LoNWoRKS platform is the leading open solution for building and home\nautomation, industrial, transportation, and public utility control networks. The\nLONWoRKS platform is accelerating the trend away from proprietary control schemes\nand centralized systems by providing interoperability, robust technology, faster\n development, and economies of scale. Distributing the processing throughout the\nnetwork using an open control networking protocol and providing easy access to\nevery device lowers the overall installation and life cycle costs, increases reliability\nby minimizing single points of failure, and providing the flexibility to adapt the\nsystem to a wide variety of applications. For example, in the building control\nindustry, LoNWoRKS networks are used to provide a common infrastructure for all\nbuilding systems. This allows the building automation system designer to eliminate\nexcessive vertical integration, which is the often the reason for vertical isolation.\nThe LoNWoRKS platform is based on the following concepts:\n1. Control systems have many common requirements regardless of application.\n 2. A networked control system is significantly more powerful, flexible, and scalable\nthan a non-networked control system.\n3. Networked control systems can leverage the control system foundation to easily\nevolve to address new applications, markets, and opportunities.\n4. Businesses can save and make more money with control networks over the long\nterm than they can with non-networked control systems.\nThe Market Value of Networked Control Systems\nMany controls applications are following the same evolutionary path followed by the\ncomputer industry. The path is from proprietary closed architectures to open\nstandard architectures, and from purpose built implementations with little room for\ngrowth to standard platforms with the flexibility to evolve to serve new applications\nnot envisioned by the original designers. This path has enabled the computer\nthe same will happen for controls.\nAn example of the evolution from purpose built to general purpose in the computer\nindustry is the evolution of word processing. The first gold standard for word\n processing was Wang Computer. They offered a purpose-built word processor which\nquickly replaced the electric typewriters used before the advent of word processing.\nThe solution was superior to electric typewriters, but ultimately purpose-built word\nprovided not only a superior solution for word processing, but also served as a\nplatform for many applications not envisioned by Wang. Users of the new general\npurpose solution benefited from word processing, spreadsheet analysis, and more-\ndecoupling the hardware from the application and setting the working model for all\nnetworks to come.\nIntroduction\n7",
    "Page_8": "An example of the evolution from purpose built to general purpose in the controls\nindustry is the evolution of lighting controls. A typical lighting control system for\nlighting a city is typically optimized for longevity, reliability, and cost. A typical\n purpose-built lighting control system relies on dedicated communications, dedicated\nuser controls, and a dedicated monitoring system (if the system supports monitoring).\n Non-lighting functions such as energy management, 911 emergency response, or\ndark sky management have seldom, if ever, been incorporated into the function of a\nstreetlighting system due to the cost and complexity of integrating the new\ncapabilities.\nThe alternative to a purpose-built lighting control system is a networked control\nsystem for streetlighting. The network that provides access to the lights is the city's\nexisting communications infrastructure—for example the city's wide-area network or\nmetro Wi-Fi service. The segment controllers manage lights and act as an interface\nto the ctiy's wide-area network; however, they are also general purpose connectivity\nproducts. Any networked product or sensor sharing the common technology of the\nstreetlighting system can be added to the segment controller. This means that the\nstreetlight is only the first end-point on the network, others can be added later-\npreserving a city's investment in the streetlighting system. For example, after the\nsystem is installed, pedestrian sensors could be added to extend the functionality of\nthe system and provide actionable data to the system—lights could brighten when a\npedestrian is detected at a crosswalk. Finally, within the lights themselves,\nembedded communications distributes the intelligence to the end-point. Doing so\nallows the lights to act independently of, or in cooperation with external information\nand events. In the case of our lighting system, were the city's WAN to fail, there\nwould be no impact on the streetlighting. Individual lights would still respond to\nlighting, time, or environmental conditions at the local level. Were pedestrian\nsensors in place, lights would still balance their output. Also, if the city enabled their\nparks and recreation reservation software to send time and location data to the\nstreetlighting system, lights could brighten at the beginning and end of night\nThe networked control system provides other benefits as well. City maintenance and\n operations personnel can view real-time and historical health data, enabling them to\n provide improved customer service, reduce downtime, eliminate excess spare part\ninventory, and reduce maintenance costs.\nAll of these benefits are achieved because the intelligence is at the end-point of the\nnetworked control system, the system is responsive to applications and external\ninformation, and the networked control system is built on a platform that can easily\nevolve to support new applications and services\nThis document is an introduction to the basics of the LoNWoRKS platform. It begins\nwith an overview of networks and protocols, provides an overview of the components\nof the LoNWoRKS platform, and highlights the technical aspects of the ISO/IEC\nstandard Control Network Protocol (CNP). The remaining sections in this chapter\nprovide an overview of LoNWoRKS networks and provide an overview of how to\nimplement a control network. Many of the technical details discussed in this\n document are handled automatically by the protocol, the network operating system,\nor network tools. The automatic handling of the lower level details of device\ncommunication is, in fact, one of the great strengths of the LoNWoRKS platform.\nIntroduction\n8",
    "Page_9": "LonWoRks Networks\nThe underlying concept of the LoNWoRKS platform is that the information in a\nsensing, monitoring, or control application is fundamentally the same across markets\nand industries. For example, a garage door and a passenger ferry door send\nessentially the same information—closed or open. A second concept underlying the\nplatform is the knowledge that networks, regardless of their function, increase in\npower as nodes are added. Metcalf's Law works in data networks and in control\nnetworks.\nIn many ways, a LoNWoRKS network resembles a traditional data network. Data\nnetworks consist of computers attached to various communications media, connected\nby routers, which communicate with one another using a common protocol such as\nTCP/IP. Data networks are optimized for moving large amounts of data, and the\ndesign of data network protocols assumes that occasional delays in data delivery and\nresponse are acceptable. Even though data networks are based on open protocols,\nmost manufacturers do not choose to develop their own data networking components\nsuch as transceivers, routers, and network operating systems—it is typically more\ncost effective to buy these components from a reliable supplier.\nAs shown in Figure , control networks contain similar components to data networks,\nbut the control network components are optimized for the cost, performance, size,\nand response requirements of control. Control networks allow networked systems to\nextend into a class of applications where data networking technology is not\nappropriate. Manufacturers of control systems and devices are able to shorten their\n development and engineering time by designing LoNWoRKS components into their\nproducts. The result is cost-effective development and consistency that allows \ndevices from multiple manufacturers to be able to communicate.\nOpuraler\nOpuraier\nlaforface\nktorfaco\nSupervisory Level\nCupntroller\nRouter\nFleld Level\nField\nField\nController!\nControllerl\nI\nRouter\nRouter\n/O Level\nFigure 1 LonWoRKs Control Network\nLONWoRKS networks range in sophistication from small networks embedded in\n machines to large networks with thousands of devices controlling fusion lasers, paper\nmanufacturing machines, and building automation systems. LoNWoRKS networks\nIntroduction\n9",
    "Page_10": "are used in buildings, trains, airplanes, factories, and hundreds of other processes.\nManufacturers are using open, off-the-shelf chips, operating systems, and parts to\nbuild products that feature improved reliability, flexibility, system cost, and\nperformance.\nEchelon manufactures a wide variety of LoNWoRKS products to help developers,\nsystem integrators, and end-users implement LoNWoRKS networks. These products\nprovide a complete LoNWoRKS solution including development tools, network\nmanagement software, power line and twisted pair transceivers and control modules,\nnetwork interfaces, routers, controllers, technical support, and training.\nImplementing a Control Network\nUnderstanding the power of the LoNWoRKS platform and leveraging that power by\napplying it to all control functions is the key to providing the most cost-effective\nsystem control solution. Leveraging is achieved by eliminating the walls between\ncontrol systems and creating a general purpose networked control system that can\nevolve with changing market requirements. A networked control system leverages a\ncan evolve to meet new opportunities and customer needs.\nIn this case, the entire system is controlled by a single control infrastructure. A\nstandard wiring scheme allows devices to easily access and share communication\nmedia. Standard network management services make the network easy to set up,\nmonitor, and control while ensuring compatibility between devices and tools from\ndifferent manufacturers. Different network control systems may have different\nneeds, however, and different users may have training in different networking tools\nThe network management standard enables multiple users to use different tools on\nthe same network at the same time. Finally, an application-level standard for the\nexchange of information between devices exists so devices can easily communicate.\nThe following sections provide a checklist for designing system-wide open control\nsystems. Following is a summary checklist:\nCost-effective network wiring\nCompatible devices\nEffective system design\nStandard network management\nStandard network tools\nCost-Effective Network Wiring\nThe base for a networked control system is cost-effective wiring. Many control\nsystems are created with costly point-to-point wiring or wiring that requires costly\nconnectors, difficult to install network topologies, or costly hubs and switches. The\nmost cost-effective wiring for commercial and industrial networks is a simple pair of\ntwisted-pair wires that can be wired in any topology, is polarity-insensitive, and only\nrequires a single terminator. The most cost-effective wiring for home, utility, outdoor\nlighting, and transportation networks is to use existing power lines—enabling a\nnetworked control system to be installed with no new wires.\nIntroduction\n10",
    "Page_11": "Compatible Devices\nIt is crucial that the devices installed on the common infrastructure share\ninformation without effort. So the next checklist item is designing and selecting\nproducts adhering to a common communication guideline. This is best achieved\nwithin the LoNWoRKS platform by choosing products that have been certified by\nLONMARK? International. See the LoNMARK Web site at www.lonmark.org for more\ninformation.\nEffective System Design\nJust as a control system implemented on a monolithic processor must be designed\ntaking into account the processing capability of the processor, a networked control\nsystem must be designed taking into account the processing capability of the\nnetwork. Network processing power is typically measured in bandwidth expressed in\npackets per second, and the intelligent network wiring selected for the first checklist\nitem determines the available bandwidth. Effective system design ensures that each\ndevice in a control network uses its appropriate share of bandwidth, and partitions\nlarge networks into multiple subnetworks to increase the total available bandwidth.\nStandard Network Management\nStandard network management provides the necessary network services and\npublished interfaces for the infrastructure. These services allow multiple tools and\napplications from multiple vendors to coexist on the network. More importantly, it\nallows the various tools to share the network data. Two solutions are available for\nLONWoRKS networks—the LNS? Network Operating System for commercial,\nindustrial, and transportation systems, and Interoperable Self-Installation (ISI) with\noptional LonBridge Server for home systems.\nIn the new open marketplace many manufacturers do not want to create entire\ncontrol systems. These manufacturers simply wish to produce best in class devices.\nA standard network management solution like LNS or ISI allows the manufacturers\nof these devices to concentrate on their device and not be concerned about creating an\nentire control system. This reality, combined with the market presence of LNS and\nISI, has caused a proliferation of manufacturers to produce best in class LoNWoRKS\nproducts for use in open systems. These products are the network tools and open\ndevices described below.\nStandard Network Tools\nNetwork tools include network integration tools as well as HMI application\ndevelopment tools, data loggers, and other applications with a system-wide view.\nNetwork tools can be developed or purchased—in either case they must be\nitem. It is possible to choose any tool for any given project, and it is also possible to\ncombine tools on the same project, as long as they are based on the same network\nmanagement solution. Tools can be chosen based on functionality and usability\nrather than who made the physical devices. For commercial and industrial network\nintegration tools, be sure to select tools that support the network operating system\nIntroduction\n11",
    "Page_12": "plug-in standard, that fully support LoNMARK functional profiles and configuration\nproperties, and that make it easy to reuse parts of your network design. These\nnetwork integration tool for open commercial and industrial LoNWoRKS networks.\nStandard Device Configuration\nTo reduce system cost, a device must not only support standard communication, it\nmust also support a standard interface for configuration. Again, the LoNMARK logo\non the device is the first place to look. The LoNMARK guidelines provide for the\nphysical layer requirements of devices as well as the common functional profiles,\ndata types, configuration capabilities, and installation methodologies.\nFor simple devices, it may be adequate for product manufacturers to simply\ndocument the configuration interface for their device. However, it's often better, and\nrequired for complex devices, if they encapsulate the knowledge into a plug-in that\ncan be run inside one of the network integration tools. The plug-in must be based on\nthe selected network management solution. This allows tools from other\nmanufacturers to install and configure the device quickly and easily.\nStandard IP Support\nThe Internet Protocol (IP) suite is the standard on which the Internet is built. A\ncontrol network must often provide for encapsulation of the control system messages\nor packets into IP packets. Messages can then be passed around the world without\nto leverage existing infrastructure is practically limitless. IP support for a\nLONWoRKS network can be provided either by an LNS Server, i.LON SmartServer, or\nLonBridge Server that is attached to both the LoNWoRKS network and the IP\nnetwork.\nGetting More Information\nThis book is organized into three chapters. Chapter 1 introduced the LoNWoRKS\nplatform and its benefits. Chapter 2 describes the components that make up the\nLoNWoRKs platform and describes how these components can accelerate\ndevelopment of LoNWoRKS devices and systems. Chapter 3 describes the ISO/IEC\n14908-1 Control Network Protocol (CNP) that is the foundation of the LoNWoRKS\nplatform . Chapter 3 also gives a detailed look at layers 1 through 7 of the protocol.\nDevelopers will mostly deal with layers 6 and 7, but will also be interested in the\ntransceiver information described in layer 1. System designers and integrators will\nbe interested in the same layers as developers, and will also be interested in\nunderstanding the options provided by layer 4.\nThe addendix provides details on layer 1 that will only be of interest to transceiver\ndesigners.\nFor more information on the LoNWoRKS platform, see the documentation available\nat www.echelon.com/docs.\nIntroduction\n12",
    "Page_13": "Introduction\n13",
    "Page_14": "Chapter 2.\nPlatform Components\nThis chapter describes the components that make up the\nLONWoRKS platform, and describes how these components\nwork together to reduce development, production,\ninstallation, and system costs.\nPlatform Components\n14",
    "Page_15": "Building a Platform\nEchelon Corporation invented the LoNWoRKS platform and the ISO/IEC 14908-1\nControl Network Protocol. Thousands of control manufacturers currently\nmanufacture LoNWoRKs devices. A partial listing of these devices is available at\nwww.lonmark.org/products.\nEchelon began the development of the LoNWoRKS platform and the Control Network\nProtocol in 1988. This initial vision continues to drive the company forward; first, by\ncreating a standard, cost effective method to allow inexpensive control devices to\ncommunicate with each other effortlessly. Then, by using the standard\ncommunication capabilities to allow devices from multiple vendors to easily\ninteroperate on the same network. Echelon understood that simply developing a\nprotocol specification would not achieve the goal of multi-vendor systems. It was\nnecessary to build a cost-effective, standard method through which the protocol could\nbe used and supply all the necessary development tools and networking products.\nThe overriding goal of the LoNWoRKS platform is to make it easy and cost effective to\nbuild open control systems. Echelon developed the LoNWoRKS platform believing\nthere were three fundamental issues that had to be addressed to create interoperable\nproducts in the control market. First, a protocol optimized for control networks, but\ngeneric in its ability to work with different types of controls had to be developed.\n Second, the cost to incorporate and deploy this protocol in devices had to be\ncompetitive. Third, the protocol had to be introduced in such a way that\nimplementation would not vary by vendor as this would destroy interoperability.\n In order to address all of these issues effectively, Echelon Corporation set out to\ncreate a complete platform for designing, creating, and installing intelligent control\ndevices. The first step was achieved through the creation of the ISO/IEC 14908-1\n Control Network Protocol, which is described in Chapter 3, The Control Network\nProtocol. Addressing the cost and deployment issues meant finding an economical\nway to provide implementations of the protocol to customers along with development\ntools. The goal of the LoNWoRKS platform is to provide a well-integrated, optimally\ndesigned, and economical platform for creating smart devices and networks. This\nchapter describes the following components that make up the LoNWoRKS platform:\nSmart Transceivers\n Development Tools\nRouters\nNetwork Interfaces\nInternet Servers\nNetwork Management\n Network Tools\nSmart Transceivers\n In order to achieve economical and standardized deployment, Echelon designed the\nNeuron? core. The Neuron name was chosen to point out the similarities between\nproper network control implementation and the human brain. There is no central\npoint of control in the brain. Millions of neurons are networked together, each\nPlatform Components\n15",
    "Page_16": "providing information to others through numerous paths. Each neuron is typically\ndedicated to a particular function, but loss of any one does not necessarily affect the\noverall performance of the network.\nThe Neuron core is available as a standalone component called the Neuron Chip. To\nfurther reduce device costs, Echelon also provides Neuron cores combined with\ncommunication transceivers, which are called Smart Transceivers.\nTo the developer and the integrator, the beauty of the Neuron core and Smart\nTransceivers lies in their completeness. The built-in communication protocol and\nprocessors removes the need for any development or programming in these areas.\nThe Smart Transceivers eliminate the need to develop or integrate a communications\ntransceiver. The Neuron core provides layers 2 through 6 of the ISO/OSI reference\nmodel of a communication protocol, and the Smart Transceiver adds layer 1. The\ndevice manufacturer only has to supply the application layer programming and the\nnetwork integrator provides the configuration for a given network installation. This\nstandardizes implementation and makes development and configuration simple and\nfast.\nMost LoNWoRKs devices take advantage of the functions of the Neuron core and use\nit as the control processor. The Neuron core is a semiconductor component\nspecifically designed for providing intelligence and networking capabilities to\nlow-cost control devices. The Neuron core includes up to four processors that provide\nboth communication and application processing capabilities. Two processors execute\nthe layer 2 through 6 implementation of the ISO/IEC 14908-1 protocol and the third\nexecutes layer 7 and the application code. LoNWoRKs 2.0 Neuron cores add a fourth\nprocessor for interrupt processing. The device manufacturer provides application\ncode to run on the Neuron core and I/O devices to be connected to the Neuron core.\nEchelon Corporation designed the original Neuron core and the LoNWoRKs 2.0\nNeuron core. Neuron cores are also designed and manufactured by Echelon's\nmanufacturing partners.\nThe Neuron core is a system-on-a-chip with multiple processors, memory, and\ncommunication and I/O subsystems. At the time of manufacture, each Neuron core is\ngiven a permanent unique-in-all-the-world 48-bit code, called the Neuron ID. A large\nfamily of Neuron Chips is available with differing speeds, memory type and capacity,\nand interfaces. Approximately 30 million Neuron cores have been shipped as of early\n2009.\nA complete operating system including an implementation of the ISO/IEC 14908-1\nprotocol, called the Neuron firmware, is available for the Neuron core.\nDevelopment Tools\n Echelon provides a broad range of tools for developing LoNWoRKS devices and\napplications. Following is a summary of the development tools for LoNWoRKS\ndevices:\nMini FX Evaluation Kit—tools and evaluation boards for evaluating the\nLONWoRKS platform. The Mini kit can be used to develop simple LoNWoRKS\napplications for a Neuron Chip or Smart Transceiver, but it does not include a\nPlatform Components\n16",
    "Page_17": "NodeBuilder FX Development Tooltools and evaluation boards for developing\nsimple or complex LoNWoRKS applications for a Neuron Chip or Smart\nTransceiver. Includes a debugger, project manager, and network integration tool.\nShortStack? Developer's Kittools and firmware for developing LoNWoRKS\napplications that run on processors that do not include a Neuron core. The\nShortStack kit includes firmware that is loaded onto a Smart Transceiver that\nmakes the Smart Transceiver a communications co-processor for the host\nprocessor.\n FTXL Developer's Kit —tools, firmware, and FPGA design files for developing\nLONWoRKS applications that run on a Nios II embedded 32-bit RISC processor\nconfigured on an Altera Cyclone II/III family FPGA device.\nDevelopers using any of these tools typically also require network integration and\ndiagnostic tools. A network integration tool is included with the NodeBuilder FX\nDevelopment Tool, but the other LoNWoRKS development tools do not include a\nnetwork integration tool. None of the development tools include a network diagnostic\ntool. Network integration and diagnostic tools are described in Network Tools later\nin this chapter.\nRouters\n Transparent support for multiple media is a unique capability of the LoNWoRKS\nplatform, allowing developers and network integrators to choose those media and\ncommunication methods best suited for their needs. Multiple media support is made\npossible by routers. Routers can also be used to control network traffic and partition\nsections of the network from traffic in another section, increasing the total\nthroughput and capacity of the network. Network tools automatically configure\nrouters based on network topology, making the installation of routers easy for\ninstallers and transparent to the devices.\nRouters allow a single peer-to-peer network to span many types of transport media\nand support tens of thousands of devices. A router has two sides, each with a\ntransceiver appropriate to the two channels to which the router is connected.\nRouters are completely transparent to the logical operation of the network, but they\ndo not necessarily transmit all packets; when configured by a network integration\ntool, intelligent routers know enough about the system configuration to block packets\nthat have no addressees on the far side. Using another type of router called an\nIP-852 router, LoNWoRKS routers can span great distances over wide-area networks\nsuch as the Internet.\nEchelon offers routers that connect different types of twisted pair channels, as well\nas IP-852 routers for routing between twisted pair channels and an IP network such\nas the Internet, an intranet, or a virtual private network (VPN). A complete list of\nthe routers available from Echelon is available at www.echelon.com/products.\nFollowing is a list of the most commonly used routers:\n i.LON SmartServer—routes between an IP-852 channel and a twisted pair\nchannel, and also provides controller functionality. The SmartServer is available\nwith and without IP-852 routing.\n· i.LON 600—routes between an IP-852 channel and a twisted pair channel.\nPlatform Components\n17",
    "Page_18": "MPR-50 Multi-Port Router—routes among up to 5 channels: four TP/FT-10 free\ntopology twisted pair and one TP/XF-1250 twisted pair.\nLonPoint Router—routes between two twisted pair channels. Six different\nmodels are available for different types of twisted pair channels.\nNetwork Interfaces\nA network interface is a card or module that is used to connect a host computer-\ntypically a computer running Microsoft Windows-to a LoNWoRKS network. The\nnetwork interface itself does not run an application—instead it provides either layer\n2 or layers 2 - 5 of the ISO/IEC 14908-1 Control Network Protocol (CNP), plus a\ntransceiver implementing layer 1, and firmware to exchange layer 2 or layer 5 CNP\npackets with the attached computer. A complete list of the network interfaces\navailable from Echelon is available at www.echelon.com/products. Following is a list\nof the most commonly used network interfaces:\nU10/U20 USB Network Interface-a small USB device that plugs into a USB\nport on a Windows computer and attaches to a free topology twisted pair (for the\nU10) or power line (for the U20) channel.\n i.LON SmartServera controller that can also be used as a network interface\nwith an IP connection to a host Windows computer.\n i.LON 600an IP-852 router that can also be used as a network interface with\nan IP connection to a host Windows computer.\nSmart Servers\nA smart serveris a programmable device that combines a controller with a Web\nserver for local or remote access, LoNWoRKS network interface, CNP network\nmanager, legacy-device interface, and optional IP-852 router. Echelon's low-cost\nsmart server is called the i.LON SmartServer. The SmartServer connects\nLoNWoRKs, Modbus, and M-Bus devices to corporate IP networks or the Internet. It\nfeatures a built-in Web server that allows Web access to all the data managed and\ncontrolled by the SmartServer, as well as built-in applications for alarming,\nscheduling, data logging, and data translation. It also includes a Web binder\napplication for bridging multiple LoNWoRKs domains, as well as bridging from\nModbus and M-Bus devices to LoNWoRKs domains. The SmartServer provides a\nSOAP/XML Web services interface for use by custom Web pages and for integration\nwith enterprise applications.\nNetwork Management\nLon Works networks can be categorized by the method used to perform network\ninstallation. The two categories of networks are managed networks and self-installed\nnetworks. A managed network is a network where a shared network management\nserveris used to perform network installation. The network management server\nmay be part of a network operating system as described later in this section, or may\ninteract with the server and define how the devices in the network should be\nPlatform Components\n18",
    "Page_19": "configured and how they should communicate. Such a tool is called a network\nmanagement tool and is described in the next section. Although a network\n management tool and a server are used to initially establish network communication,\nthey need not be present all the time for the network to function. The network\nmanagement tool and server are only required whenever changes are made to the\nnetwork's configuration.\nIn a managed network, the network management tool and server allocate various\nnetwork resources, such as device and data point addresses. The network\nmanagement server is also aware of the network topology, and can configure devices\nThe alternative to a managed network is a self-installed network. There is no central\ntool or server that manages the entire network configuration in a self-installed\nnetwork. Instead, each device contains code that replaces parts of the network\nmanagement server's functionality, resulting in a network that no longer requires a\nspecial tool or server to establish network communication or to change the\nconfiguration of the network.\nNetwork installation includes the following steps:\n· Assigning logical addresses to all devices and groups of devices.\n· Binding the network variables to create logical connections between devices.\n Configuring the various control network protocol parameters in each device for\nthe desired features and performance, including channel bit rate,\nacknowledgement, authentication, and priority service.\nNetwork installation may be quite complex, but the complexity is hidden by the\nnetwork management solutions that are part of the LoNWoRKS platform. For\nmanaged applications, functional network design can be as simple as dragging the\n devices' application functional blocks onto a drawing and connecting inputs and\noutputs to determine how functional blocks communicate with each other. The\nnetwork management tool automatically assigns logical addresses, binds network\nvariables based on the connections drawn by the integrator, and configures network\ncontrol parameters. For self-installed applications, functional network design is as\nsimple as plugging in a pair of devices and pressing a button on each device to\nestablish communication.\nThe network installation process for managed networks can be either an ad hoc\nprocess or a pre-engineered process. The network installation process for\nself-installed networks is typically an ad hoc process. In the ad hoc method, the\ndevices are first connected to the network and powered-up, and the configuration\ndata is either self-installed or downloaded over the network as each device is defined\nin a network integration tool. In the engineered method, the information is collected\ninto a database by the network integration tool and is downloaded to the devices at\ninstallation time. For a managed network using either method, the network\nintegration tool automatically maintains a database that accurately reflects the\nconfiguration of each device in the system.\nNetworks can start out as self-installed networks using ISI and, as size or complexity\ngrows beyond the ISI limits, can be upgraded into a managed network. A\nself-installed network may also be transitioned to a managed network to take\nPlatform Components\n19",
    "Page_20": "advantage of the additional flexibility and capability provided by a network\nmanagement tool and server.\nNetwork Operating System\nFor managed networks, a network operating system (NOS) can be used to provide a\ncommon, network-wide set of services supporting monitoring, supervisory control,\ninstallation, and configuration. The NOS also provides programming extensions for\neasy use of network management and maintenance tools. A LoNWoRKs NOS\nadditionally provides data access services for HMI and SCADA applications as well\nas remote access via LoNWoRKS or IP networks.\nA properly designed NOS allows for synchronization services between multiple tools\nand applications used by a single or multiple users. In order for a NOS to support\ncomplete interoperability, it must support standard plug-ins by multiple\nmanufacturers for easy device configuration.\nA properly designed NOS is not required for the normal operation of a system. The\nNOS provides installation and maintenance services when a network is initially\ncommissioned or later changed, but once a network is installed, the NOS is not\nrequired to support communication between devices. This is a significant benefit of\nthe peer-to-peer architecture of the LoNWoRKS platform. Managed networks that\nintegration and do not utilize a NOS. These system-to-system solutions are not\ncapable of separating their functionality from their hardware design. Instead, such\nsolutions rely on multiple, custom interfaces to achieve a partial separation of\napplication from design.\nTo provide interoperability between network tools and applications, the LoNWoRKS\nplatform includes a single NOS for managed networks called the LNS Network\napplications on LoNWoRKS networks. LNS is an infrastructure that provides the\nfoundation for interoperable LoNWoRKS network tools and applications, which are\nproducts used in designing, configuring, installing, operating, and maintaining\nLoNWoRKS networks. LNS supports clients and servers based on Microsoft\nWindows.\nLNS uses a client/server architecture so that multiple applications can be active on a\nnetwork at the same time, allowing multiple users to install devices, operate a\nsystem, diagnose problems, and make repairs simultaneously. LNS is scalable,\nchangeable, and upgradeable.\nThe LNS plug-in standard encourages LoNWoRKS device manufacturers to provide\nmore value to users through software components linked to their unique products.\nRather than trying to develop custom programming for each project in the field,\nThese device plug-ins often contain built-in troubleshooting tools, user dialogs to aid\nor confirm configuration choice, as well as custom user interfaces to monitor or graph\ndata held in the device. In effect, manufacturers can write smart software once to\nsimplify the use of their products in thousands of LoNWoRKS networks.\nUsing LNS, a manufacturer's device plug-in software runs without modification in\nany Windows computer, and can be seamlessly integrated with the installation tools\non the computer. LNS plug-ins simplify the management of the network by masking\nPlatform Components\n20",
    "Page_21": "the underlying communication mechanisms between the software component and the\n device. Thus, many existing devices can become fully interoperable by simply writing\na plug-in. A standard interface is set for manufacturers to customize the front end,\nwhile LNS makes it possible for multi-vendor software components to work together.\nInteroperable Self-lnstallation (Isl)\nEach device in a self-installed network is responsible for its own configuration and\ndoes not rely on a network management server to coordinate its configuration.\nBecause each device is responsible for its own configuration, a common standard is\nrequired to ensure that devices configure themselves in a compatible way. The\nstandard protocol for performing self-installation with the LoNWoRKS platform is\ncalled the LoNWoRKs Interoperable Self-Installation (ISI) Protocol. The ISI protocol\ncan be used for networks of up to 200 devices and enables LoNWoRKs devices to\n discover and communicate with each other. Larger or more complex networks must\neither be installed as managed networks, or must be partitioned into multiple\nsmaller subsystems, where each subsystem has no more than 200 devices and meets\nthe ISI topology and connection constraints. Devices that conform to the LoNWoRKS\nISI protocol are called ISI devices.\nThe LonBridge Server can be used to create an interface between an IP network and\na network of ISI devices. The LonBridge Server is available for Windows and Linux,\nand can be freely ported to other platforms.\nNetwork Tools\nNetwork tools are software applications built on top of the network operating system\nfor network design, installation, configuration, monitoring, supervisory control,\ndiagnostics, and maintenance. Many tools combine these functions, but the most\ncommon combinations are the following:\n Network Integration Tools. Provide the essential functions required to design,\nconfigure, commission, and maintain a network.\n Network Diagnostic Tools. Special-purpose tools to observe, analyze, and\n diagnose network traffic and monitor network loading.\nHMI Development Tools. Tools for creating human-machine interface (HMI)\napplications. HMI applications are used for operator interfaces to operational\nsystems.\nI/O Servers. General-purpose drivers that provide access to LoNWoRKS networks\nfor HMI applications not originally designed for LoNWoRKS networks.\nNetwork tools based on the LNS Network Operating System are interoperable,\nmeaning they can operate at the same time on the same network and maintain a\nconsistent view of the devices in the network and their configuration. Echelon's\nofferings for network tools include the LonMaker Integration? Tool and the\nLonScanner'\" Protocol Analyzer, which are described in the following sections.\nPlatform Components\n21",
    "Page_22": "LonMaker Integration Tool\nThe LonMaker Integration Tool is a software package for designing, documenting,\ninstalling, and maintaining multi-vendor, open, interoperable LoNWoRKS networks.\nBased on the LNS Network Operating System, the LonMaker tool combines a\n powerful client-server architecture with an easy-to-use Visio user interface. The\nresult is a tool that is sophisticated enough to design, commission, and maintain a\n distributed control network, yet provide the ease-of-use required by network design,\ninstallation, and maintenance staff.\nThe LonMaker tool conforms to the LNS plug-in standard. This standard allows\nLONWoRKs device manufacturers to provide customized applications for their\nproducts, and have these customized applications automatically started when the\nLonMaker user selects the associated device. This makes it easy for system\nengineers and technicians to define, commission, maintain, and test the associated\ndevices.\nFor engineered systems, network design is usually done off-site, without the\nLonMaker tool attached to the network. Network design may, however, take place\non-site, with the tool connected to a commissioned network. This feature is especially\n desirable for smaller networks or where adds, moves, and changes are a regular\noccurrence.\nUsers are provided with a familiar, CAD-like environment for designing a control\nsystem. Visio's smart shape drawing feature provides an intuitive, simple means for\ncreating devices. The LonMaker tool includes a number of smart shapes for\nLONWoRKS networks, and users can create new custom shapes. Custom shapes may\nbe as simple as a single device or functional block, or as complex as a complete\nsubsystem with predefined devices, functional blocks, and connections between them\nUsing custom subsystem shapes, additional subsystems can be created by simply\n dragging the shape to a new page of the drawing, a time-saving feature when\ndesigning complex systems. Any subsystem can be changed to a supernode by adding\nnetwork variables to the subsystem shape. Supernodes reduce engineering time by\nexposing a simplified interface to a set of devices.\nNetwork installation time is minimized by the ability of the installer to commission\nmultiple devices at the same time. Devices can be identified by service pin, bar code\nscanning Neuron IDs, winking, or manually entering the IDs. Auto discovery can be\nused for systems containing embedded networks to automatically find and\ncommission the devices in the system. Testing and device configuration is simplified\nby an integrated application for browsing network variables and configuration\n properties. A management window is provided to test, enable/disable, or override\nindividual functional blocks within a device or to test, wink, or set online and offline\nstates for devices.\nThe LonMaker tool can both import and export AutoCAD files and generate as-built\ndocumentation. An integrated report generator and bill-of-materials generator can\nalso be used to generate detailed reports of the network configuration.\nThe LonMaker tool is a single expandable tool covering the entire life cycle of the\nnetwork to simplify the tasks of installers.\nPlatform Components\n22",
    "Page_23": "LonScanner Protocol Analyzer\nThe LonScanner Protocol Analyzer is a software package that provides network\ndiagnostic tools to observe, analyze, and diagnose the behavior of installed\nLONWoRKS networks.\nThe protocol analyzer can be used to collect, timestamp, and save all CNP packets on\na LoNWoRKs channel. Packets are saved in log files that can be later viewed and\nanalyzed; packets may also be viewed in real-time as they are collected by the\nprotocol analyzer.\nA sophisticated transaction analysis system examines each packet as it arrives and\nassociates related packets to aid the user in understanding and interpreting traffic\n patterns in their network.\n Logs can be displayed in summary form with one packet per line for quick analysis,\nor in expanded form with one packet per window for more detailed analysis. Using\ndata imported from an LNS database, the protocol analyzer decodes and displays\npacket date using the device and network variable names assigned during\ninstallation. It also provides text descriptions of each message and a description of\nthe CNP message service used to transmit it. Eliminating the need for the user to\nmanually interpret the ones and zeros of CNP reduces the time and effort needed to\ndiagnose network problems.\nThe user can specify capture filters to limit the packets collected. Filters can be used\nto limit the captured packets to packets between selected devices or network\nvariables, or to packets using selected CNP services.\nA traffic statistics tool provides access to detailed statistics related to network\nbehavior. The statistics include total packet counts, error packet counts, and\nnetwork loading. The statistics display provides the user with an easy-to-read\nsummary of network activity.\nPlatform Components\n23",
    "Page_24": "Platform Components\n24",
    "Page_25": "Chapter 3.\nThe Control Network Protocol\nThe ISO/IEC 14908-1 Control Network Protocol (CNP) is\nthe foundation of the LoNWoRKS platform and provides a\nreliable, cost-effective, and robust communications\nstandard for control applications. This chapter describes\nthe protocol and the services implemented by each layer\nof the protocol. Developers will mostly deal with layers 6\nand 7, but will also be interested in the transceiver\ninformation described in layer 1. System designers and\nintegrators will be interested in the same layers as\ndevelopers, and will also be interested in understanding\nthe options provided by layer 4.\nThe appendix provides details on layer 1 of the protocol\nthat will only be of interest to transceiver designers.\nThe Control Network Protocol\n25",
    "Page_26": "ISO/lEC 14908-1 Control Network Protocol\nThe foundation of the LoNWoRKS platform is the ISO/IEC 14908-1 Control Network\nProtocol (CNP), just as the RFC-791/793 TCP/IP protocol is the foundation of most\ndata networks and the Internet. There are many compatible implementations of the\nISO/IEC 14908-1 protocol. Echelon's implementation of CNP is called the LonTalk@\nprotocol. Throughout this document, the ISO/IEC 14908-1 Control Network Protocol\nis referred to simply as CNP. CNP also refers to the ISO/IEC physical layer\nstandards defined by ISO/IEC 14908-2 and 14908-3, and the IP tunneling standard\ndefined by ISO/IEC 14908-4.\nCNP is designed to support the needs of control applications spanning a range of\nindustries and requirements. To meet its broad objectives, the protocol is a complete\nseven-layer communications protocol, with each layer optimized to the needs of\ncontrol applications. The seven layers follow the reference model for open systems\nBy addressing all seven layers defined by the OSI reference model, CNP provides a\nrobust communications solution that meets the needs of a broad range of applications\ntoday, and will continue to meet the needs of evolving control applications in the\nfuture.\nThe following list summarizes the major features of CNP:\nEfficient delivery of small messages. A typical control message may consist of 1\nto 8 bytes of data, though larger and smaller messages are supported. A CNP\ndevice can transmit a message with as few as 9 bytes of protocol overhead.\nMessages may be delivered to a single device or to any group of devices.\n Reliable delivery of messages. Even though an individual message may consist of\na few bytes, the reliable delivery of every message may be critical to the\napplication. CNP includes reliable message delivery services that retry a\nmessage transmission when a communication failure occurs and informs the\nsending application if an unrecoverable failure occurs. Resynchronization is\nimmediate if a previously unreachable destination becomes reachable within the\nretry interval.\n Duplicate message detection. Some types of control messages must not be\ndelivered multiple times. For example, if a monitoring application that is\nbecome incorrect. CNP prevents duplicate messages from being passed to the\nreceiving application.\n Multiple communications media. Many control systems require multiple\ncommunications media for lowest total system cost. Twisted-pair cable provides\nthe best performance and is a good solution where it is practical to install the\ncable. Link power communications lowers device costs by providing power over\nthe same media as communications. Communications over existing power lines\nprovides the lowest installation cost. CNP is media independent so that all these\nmedia, and more, are supported. In addition, CNP also supports routers so that\n devices on different channels can interoperate. A hierarchical addressing scheme\nis used to support low-cost and easily maintained routers.\nLow device cost. A control device may be as simple as a sensor for a single point\nsuch as a limit switch or a temperature sensor. With the capability to put control\nin every point, it is important that the protocol not be too demanding in terms of\nmemory and computing resources at each device. CNP is optimized to minimize\nThe Control Network Protocol\n26",
    "Page_27": "the code size of protocol firmware and to minimize RAM requirements for buffer\nstorage. For example, the complete implementation of CNP running on a Neuron\ncore requires less than 10 Kbytes of code and less than 1 Kbyte of RAM.\nLow installation and maintenance cost. Low device cost does not lead to low\nsystem cost unless devices are easily installed in networks, networks are easily\nmodified, and repairing networks after a failure is simple. CNP includes\ncomplete support for installation and maintenance so that simple devices in\nsimple networks can manage their own network installation, low-cost installation\ntools can be used to install and maintain more complex networks, and low-cost\ndiagnostic tools can be used to diagnose failures in any type of network\nEfficient use of channel bandwidth. To keep system costs down, many devices\nmust be able to efficiently share a single communications channel. CNP uses\ninnovative media access technologies to provide the most efficient use of the\ncommunications channels, even under conditions of high loading.\nInteroperable systems. Multiple systems may need to interoperate to provide\nadditional benefits to the end users. For example, a fire alarm system may\ninteroperate with an elevator control system to keep elevators away from burning\nfloors and may interoperate with an emergency exit lighting system to illuminate\nexit signs. In addition to supporting interoperability between devices, CNP also\nallows devices from different vendors to be installed using a common set of\ninstallation strategies and tools.\n Separation of systems. Multiple systems that should not interoperate may share\na common communication medium, especially in the case of open media such as\npower line. CNP allows these systems to operate independently without mutual\ninterference by isolating devices that communicate with each other into domains.\nA domain is a logical collection of devices that communicate with each other.\nDevices in different domains cannot communicate directly with each other—they\nmust communicate through a common gateway.\nPrevent tampering. Because control systems do more than just move data, it\nshould not be possible for an unauthorized user to inject commands into the\nnetwork. CNP includes an authentication protocol that prevents tampering by\nunauthorized users.\nCNP Layers\nTo provide a low-cost, reliable, and robust communications standard, CNP is layered\nas recommended by the International Standards Organization Open Systems\nInterconnect (ISO OSI) reference model. The OSI layers ensure that the required\nservices are provided without unexpected interactions between the services.\nCNP provides the following services for each of the seven layers of the OSI reference\nmodel:\n1. The physical layer defines the transmission of raw bits over a communication\nchannel. A channelis a physical transport medium for packets. The physical\nlayer ensures that a 1 bit transmitted by a source device is received as a 1 bit by\nall destination devices. CNP is media independent, so multiple physical layer\nprotocols are supported depending on the communication medium.\n2. The link layer defines media access methods and data encoding to ensure\nefficient use of a single communications channel. The raw bits of the physical\nlayer are combined into data frames. The link layer defines when a source device\nThe Control Network Protocol\n27",
    "Page_28": "can transmit a data frame, and defines how destination devices receive the data\nframes and detect transmission errors. A priority mechanism is also defined to\nensure priority delivery of urgent messages.\n3. The network layer defines how message packets are routed from a source device\nto one or more destination devices. This layer defines naming and addressing of\ndevices to ensure the correct delivery of packets. This layer also defines how\nmessages are routed between the source and destination devices when these\ndevices are on different communication channels.\n4. The transport layer ensures reliable delivery of message packets. Messages can\nbe exchanged using an acknowledged service, where the sending device waits for\nan acknowledgement from the receiver and resends the message if the\nacknowledgement is not received. The transport layer also defines how duplicate\nmessages are detected and rejected if a message is resent due to a lost\nacknowledgement.\n5. The session layeradds control to the data exchanged by the lower layers. It\nsupports remote actions so that a client may make a request to a remote server\nand receive a response to this request. It also defines an authentication protocol\nthat enables receivers of a message to determine if the sender is authorized to\nsend the message.\n6. The presentation layer adds structure to the data exchanged by the lower layers\nby defining the encoding of message data. Messages may be encoded as network\nvariables, application messages, or foreign frames. Interoperable encoding of\nnetwork variables is provided with standard network variable types (SNVTs).\nPresentation layer services are provided by the Neuron firmware for applications\nhosted on a Neuron Chip or Smart Transceiver; these services are provided by a\nhost processor and a LoNWoRKS network interface for applications running on \nother hosts.\n 7. The application layer defines standard network services that use data exchanged\nby the lower layers. Standard network services are provided for network\nconfiguration, network diagnostics, file transfer, application configuration,\napplication specification, alarming, data logging, and scheduling. These services\nensure that devices created by different developers or manufacturers can\ninteroperate with each other, and can be installed and configured using standard\nnetwork tools.\nTable 1 summarizes the OSI reference model layers and the CNP services provided\nat each layer.\nTable 1 CNP Layers\nOSI Layer\nPurpose\nServices Provided\nPhysical\nElectrical Interconnect\nMedia-S pecific Interfaces and\nModulation Schemes (twisted pair,\npower line, radio frequency,\ncoaxial cable, infrared, fiber optic)\nLink\nMedia Access and Framing\nFraming; Data Encoding;\nCRC Error Checking;\nPredictive CSMA;\nCollision Avoidance;\nPriority & Collision Detection\nThe Control Network Protocol\n28",
    "Page_29": "OSI Layer\nPurpose\nServices Provided\nNetwork\nMessage Delivery\nUnicast & Multicast Addressing;\nRouters\n4\nTransport \nE nd-to-E nd Reliability\nAcknowledged & Unacknowledged\nMessage Delivery;\nCommon Ordering;\n Duplicate Detection\nSession\nControl\nRequest-Response;\n5\nAuthentication\n Presentation\nData Interpretation\nNetwork Variables;\nApplication Messages;\nForeign Frame Transmission\nApplication\nApplication Compatibility\nNetwork Configuration;\n Network Diagnostics;\nFile Transfer;\nApplication Configuration;\nApplication S pecification; \nAlarming;\nData Logging;\nScheduling\nCNP Data Transmission\nCNP ensures that application data sent by a source device is correctly received by the\napplications on one or more destination devices. CNP layers described in the\nprevious section define transformations on the sending device's application data that\n occur between the application and the raw bits that are transmitted on the\ncommunication channel; the CNP layers define a similar set of transformations on\nthe destination devices that change the raw bits back to the original data. The\ntransformations performed by layers 2 through 6 consist of headers that are added to\nthe application data. Table 2 summarizes the data carried by each layer.\nTable 2 Data ateach CNP Layer\nLayer\nData\nPhysical\nRaw Bits\n2\nLink\nData Frame\n3\nNetwork\nDatagram\n4\nTransport\nTransport Packet\n5\nSession\nSession Packet\n6\n Presentation\nPresentation Packet\nApplication\nMessage\n7\nThe Control Network Protocol\n29",
    "Page_30": "Figure illustrates the contents of a typical CNP data frame as carried by the\n physical layer.\nmsb\nlsb\nBitsync (configurable number of 1 bits)\n0\nLink Header (1 byte)\nNetwork Header (4 to 16 bytes)\nTransport Header (0 to 1 bytes)\nSession Header (0 to 1 bytes)\nPresentation Header (1 to 2 bytes)\nApplication Data (0 to 246 bytes)\nLink CRC (2 bytes)\nFigure 2 CNP Data Frame\nThe format of the headers for each layer is described in the sections within this\nchapter. Each section includes diagrams similar to the preceding diagram that\ndescribes the bit and byte format of the fields within the data frame. Bytes are\ntransmitted from top to bottom, with multi-byte fields transmitted least significant\nbyte first. Bits are transmitted from right to left within a byte, which is least\nsignificant bit first.\nCNP Limits\nCNP supports up to 32,385 devices per domain, and a practically unlimited number\nof domains (the domain identifier may be 0, 1, 3, or 6 bytes long). Each CNP device\nhas a unique 6-byte identifier and can also be configured to recognize logical\naddresses using subnet, node, and group identifiers as described in the layer-3\ndocumentation in Chapter 3. Devices typically communicate with data values called\nnetwork variables that are described in the layer-6 documentation in Chapter 3. To\nsupport flexible connection topologies for network variables, CNP defines network\nvariable aliases as describe in the layer-6 documentation in Chapter 3. Any CNP\n device can monitor and update any number of network variables in a domain, but \nnetwork variable reads and writes are simplified by using network variable\nconnections as described in the layer-6 documentation in Chapter 3—these\nconnections require bindable network variables and network variable aliases. The\nfollowing limits apply per CNP domain. These concepts are described in more detail\nin Chapter 3. The network variable and network variable aliases may be further\nlimited by the CNP implementation on a device.\nA maximum of 32,385 devices per domain.\nA maximum of 255 subnets per domain.\nA maximum of 256 groups per domain.\nA maximum of 127 devices per subnet.\nA maximum of 64 devices per group for acknowledged services\nA maximum of 32,385 devices per group for unacknowledged and repeated\nservices.\nA maximum of 4096 bindable network variables per device.\n A maximum of 8192 network variables aliases per device.\nThe Control Network Protocol\n30",
    "Page_31": "Layer 1- Physical Layer\nThe physical layer defines the transmission of raw bits over a communication\nchannel. A channelis a physical transport medium for packets. The physical layer\nensures that a 1 bit sent by a source device is received as a 1 bit by all destination\ndevices.\nCNP is media independent, so multiple physical layer protocols are supported\ndepending on the communication medium. A LoNWoRKs device can be connected to\na variety of communications transceivers that manage the electrical interconnection\nto the communications medium. CNP communications transceivers are available for\ncommunication over twisted pair, link power, power line, radio frequency (RF), fiber\noptic, and infrared media. The specifications for each LoNWoRKS transceiver provide\nthe distance, bit rates, and topologies supported.\nA LoNWoRKS network is composed of one or more channels. The physical form of a\nchannel depends on the medium. For example, a twisted pair channel is a twisted\n pair cable; an RF channel is a specific radio frequency carrier; a power line channel is\n a specific band carried on a contiguous section of power wiring.\nMultiple channels are connected by routers. Routers are communication devices that\nconnect two channels and route packets between them. Routers can be installed to\nuse one of four routing algorithms: configured router, learning router, bridge, or\nrepeater. Configured routers and learning routers are a class of router known as an\nintelligent router.\nA set of channels connected by bridges or repeaters is a segment. A device sees every\npacket from every other device on its segment. Intelligent routers can be used to\nisolate traffic within a segment to increase total system capacity and improve\nreliability.\nThe bit rate of a channel is dependent upon the medium and transceiver design.\nMultiple transceivers with different bit rates may be designed for a medium to allow\ntrade-offs of distance, throughput, and device power consumption and cost. Typical\nbit rates are 78.1 kbps for TP/FT-10 (ISO/IEC 14908-2) and Ethernet bit rates for\nIP-852 (ISO/IEC 14908-4).\nChannel Types\nTable 3 lists the common LoNWoRKS communication channel types. All of these\n media are bidirectional, supporting transmission and reception of data by every\ndevice. The ID column in the table lists unique identifiers for each channel type that\ncan be used by a network tool to verify compatibility between the device and its\nchannel. The Description column in the table lists the specification that defines the\ncharacteristics of the channel. The Standard column in the table identifies the\nchannel types that can be used to create devices that can be certified by LoNMARK\n International. Additional standard channel types are listed at\nwww.lonmark.org/mid.\nThe Control Network Protocol\n31",
    "Page_32": "Table 3Common LoNWoRKs Channel Types\nName\nID\nMedia\nBit Rate\nDefinition\nStandard\nIP-852\n154\nIP-852 Tunneling\nN/A\nISO/IEC 14908-4\nYes\nPL-20A\n15\nCENELEC A-band\n2613bps\nISO/IEC 14908-3\nYes\nPower Line\nPL-20C\n16\nCENELEC C-band\n156.3k/3987bps\nISO/IEC 14908-3\nYes\nPower Line w/access\nprotocol\nPL-20N\n17\nCENELEC C-band\n156.3k/3987bps\nISO/IEC 14908-3\nYes\n Power Line w/o access\nprotocol\nTP/FT-10\n Free Topology Twisted\n4\n78.13kbps\nISO/IEC 14908-2\nYes\nPair\nTP/XF-1250\n3\nTransformer-lsolated\n1.25Mbps\nLoNMARK Interoperability\nYes\nTwisted Pair\nGuidelines\n See the documents listed in the Definition column in Table 3 for more information on\nany of the channel types.\nTP/FT-l0 Free Topology Twisted Pair\nA conventional control system using bus topology wiring (such as RS-485) consists of\na network of sensors and control outputs that are interconnected using a shielded\ntwisted wire pair. In accordance with RS-485 guidelines, all of the devices must be\nwired in a bus topology to limit electrical reflections and ensure reliable\ncommunications. There is a high cost associated with installing and maintaining the\ncable plant that links together the many elements of an RS-485-based control system.\nBus topology wiring is more time consuming and expensive to install because the\ninstaller is unable to branch or star the wiring where convenient: all devices must be\nconnected directly to the main bus.\nThe best solution for reducing installation and maintenance costs and simplifying\nsystem modifications is a free topology communication system. The TP/FT-10\nchannel type offers just such a solution, and provides an elegant and inexpensive\nmethod of interconnecting the different elements of a distributed control system.\nThe TP/FT-10 channel type uses transceivers that conform to the ISO/IEC 14908-2\nFree-Topology Twisted Pair Channel Specification on free-topology twisted pair\nmedia and supports a 78,125 bps bit rate. These transceivers encode data using\ndifferential Manchester encoding as described earlier in this chapter in Single-Ended\nMode, which is polarity insensitive. A TP/FT-10 channel consists of up to 64 devices\non a single network segment; or 128 devices along with a link power source, which\nsupplies DC power to the devices on the channel. The total network length and\nnumber of devices may be extended by use of CNP routers, and/or one TP/FT-10\nphysical-layer repeater.\nA free topology architecture allows the user to wire the control devices with virtually\nno topology restrictions. Figure 3 illustrates a typical network using a TP/FT-10\nchannel. In this example, power is supplied by a local +5VDC power supply located\nThe Control Network Protocol\n32",
    "Page_33": "at each device. Power may optionally be carried over the same pair of wires as the\ndata.\nSensor-\nFT Smart\nAeiuater\nFTSmart\nDevice\nFT Sm\nTaadkitiansl\ndrises\nFT Termir\n Figure 3 Example TP/FT-10 Channel Wiring\n Unlike bus wiring designs, a TP/FT-10 channel uses a wiring scheme that supports\nany combination of star, loop, and bus wiring. Figure 4 illustrates the channel\ntopologies supported by the TP/FT-10 channel.\n口\n口\n Slngby-Temlnetad Bue Topology\n口\nStarTepelogy\n口\nDoubly-Tomlnatad Bue Tepology\n口\n口\nFrs Topelogy\nFT devloe\nLoop Topology\n=FT tomlnaton\nFigure 4 TP/FT-10 Supported Topologies\nThe wiring flexibility provided by the TP/FT-10 channel type has many advantages:\n1.\nThe installer is free to select the method of wiring and termination location that\nbest suits the installation, reducing the need for advanced planning and allowing\nlast minute changes at the installation site.\nThe Control Network Protocol\n33",
    "Page_34": "2. If installers have been trained to use one style of wiring for all installations, free\ntopology technology can be introduced without requiring retraining.\n3. Retrofit installations with existing wiring plants can be accommodated with\nminimal, if any, rewiring. This capability ensures that TP/FT-10 technology can\nbe adapted to both old and new projects.\n4. Free topology permits TP/FT-10 systems to be expanded in the future by simply\ntapping into the existing wiring where it is most convenient to do so. This\nreduces the time and expense of system expansion, and from the user's\nperspective, keeps down the life cycle cost of the free topology network.\nLink Power System\nA TP/FT-10 channel without link power requires separate data and power wiring.\nInstalling separate data and power wiring implies that a technician's time will be\nspent troubleshooting the wiring harness to isolate and repair cable faults.\nMoreover, each time a sensor is added or an actuator is moved, both data and power\nwiring must be changed accordingly, often resulting in network down time until the\nnew connections can be established.\nThe TP/FT-10 link power system provides the best solution for reducing installation\nand maintenance costs and simplifying system modifications by combining power and\n data on a common twisted wire pair. The link power system sends power and data\non a common twisted wire pair, and allows the user to wire the control devices with\nvirtually no topology restrictions. Support for link power can be added to any\nTP/FT-10 channel and can be designed into any TP/FT-10 device. A TP/FT-10\nchannel with link power can support a combination of locally powered and link\npowered devices. Link powered devices can be created using a Neuron Chip and the\nEchelon LPT-11 Link Power Twisted-Pair Transceiver. The LPT-11 transceiver\nintegrates a link powered switching power supply that provides regulated +5VDC for\nthe device to power the Neuron Chip, application electronics, sensors, actuators, and\ndisplays. Each transceiver can provide +5VDC at up to 100mA.\nPower for a TP/FT-10 channel is supplied by a central 48VDC power supply, and\nflows through an LPI-10 Power Supply Interface onto the twisted pair wire (see\nFigure 5). The LPI-10 module isolates the power supply from wiring faults on the\ntwisted pair, couples power to the system wiring, and terminates the twisted pair\nnetwork.\nThere are two versions of the LPI-10 interface: a simple, low-cost, inductor-based\ndesign used with custom power supplies, and an electronic LPI-10 interface used\nwith off-the-shelf 48VDC power supplies.\nThe Control Network Protocol\n34",
    "Page_35": "LPT 11\nDovioo\nFT Smart Transceive\nDevice\n42.4VBman\nLPT-11\nFT Smart\nDevice\nLPT-11\nDevice\nFigure 5 Example TP/FT-10 with Link Power System Wiring\nEach link-powered device located along the twisted wire pair includes an integral\nswitching power supply. This supply regulates the voltage on the twisted pair down\nto +5VDC at currents up to 100mA for use by the device. If a high current or high\nvoltage device must be controlled, then the +5VDC power can be used to trigger an\nisolating high current triac, relay, or contactor.\nThe integral power supply does away with the need for a local AC-to-DC power\nsupply, charging circuit, battery, and the related installation and labor expenses.\nThe savings in money and time that results from eliminating the local power supply\ncan be up to 20% of the total system cost; the larger the system, the greater the\nsavings. Moreover, if standby batteries are used, then additional savings will be \nrealized throughout the life of the system, because only one set of batteries will\nrequire service.\nThe link power system uses a single point of ground, at the LPI-10 module, and all of\nthe link power transceivers electrically float relative to the local ground. Differential\ntransmission minimizes the effects of common mode noise on signal transmission. If\n grounded sensors or actuators are used, then either the communication port or the\nI/O lines of the device must be electrically isolated.\nTP/FT-10 Transceivers\nFT5000\nFigure 6 FT 5000 Smart Transceiver\nSeveral TP/FT-10 transceivers are available that device manufacturers can use to\ncreate TP/FT-10 devices. For locally-powered devices, the Echelon FT 5000 Smart\nTransceiver provides the most cost-effective solution because it is the lowest cost\nsolution that combines a TP/FT-10 transceiver with a Neuron core that implements\n CNP and also executes the device application.\nThe Control Network Protocol\n35",
    "Page_36": "The Echelon LPT-11 transceiver can be used with Neuron Chips from Echelon,\nCypress, or Toshiba to create link-powered TP/FT-10 devices. The LPT-11 includes\nan integral 1o0mA power supply for powering the link-powered device.\nTP/FT-10 Cables\nEchelon has qualified a variety of cables for use with TP/FT-10 channels. Based on\nthe cost, performance, and availability of these different cable types, system\ndesigners can choose the most appropriate cable for their application. Echelon has\nqualified the following generic cable types:\n·A generic 16AWG (1.3mm diameter) cable (similar to Belden 8471 or 85102)\nNEMA Level 4 cable (this cable is not equivalent to TIA Category IV cable)\n?\nTIA Category 5 cable\n· JY(St)Y for specific applications in the European market\nThe electrical specifications for these cables can be found in the FT 5000 Smart\nTransceiver Data Book. A list of cable vendors can be found in the Junction Box and\nWiring Guidelines for Twisted Pair LoNWoRKs Networks engineering bulletin.\nThese cables have been qualified by Echelon in a generic form, and are available from\nvendors in a number of variations, including shielded, unshielded, plenum, and\nnon-plenum jacketing.\nTP/FT-10 Specifications\nTable 4 lists the transmission specifications for free topology TP/FT-10 channels.\nThe maximum total wire length is the total length of wire with a TP/FT-10 segment.\nThe specifications can be increased by using doubly-terminated bus topology as\nshown in Table 5.\n Up to 64 locally-powered TP/FT-10 devices or 128 link-powered devices are\nallowed per network segment. If both locally-powered and link-power devices are\nused on a TP/FT-10 channel, a maximum of 128 network loads can be attached to\nthe channel, where a locally-powered device counts as two loads and a\nlink-powered device counts as one load.\n·\n For free topology TP/FT-10 channels, the distance from each transceiver to all\nother transceivers and to the termination (including the LPI-10 termination, if\nused) must not exceed the maximum device-to-device distance shown in Table 4.\n If multiple paths exist, such as a loop topology, then the longest path should be\nused for calculations.\n The average temperature of the wire must not exceed +55°C, although individual\nsegments of wire may be as hot as +85°C.\nAs a general rule, the TP/FT-10 channel communication cables should be\nseparated from high voltage power cables. Local electrical codes must be followed\nwith regard to cable placement.\nA doubly-terminated bus may have stubs of up to 3 meters from the bus to each\ndevice.\nThe sum of the application current of all the link-powered devices in a segment\nmust not exceed 3.2A at +5V.\nThe Control Network Protocol\n36",
    "Page_37": "Table 4 TP/FT-10 Free Topology Transmission Specifications\nCable\nMaximum\nMaximum Total\n Maximum Total\nDevice-to-device\nWire Length\nWire Length\nDistance\nwithout Link\nwith Link\nPower (meters)\nPower(meters)\nBelden 85102\n500\n500\n500\nBelden 8471\n400\n500\n400\nLevel IV,\n400\n500\n400\n22AWG\nJY(st) Y 2x2x0.8 \n250\n450\n320\nTIA Category 5\n250\n450\n400\nCable\nMaximum Bus Length\nMaximum Bus Length\nwithout Link Power\nwith Link Power\n(meters)\n(meters)\nBelden 85102\n2700\n2200\nBelden 8471\n2700\n2200\nLevel IV, 22AWG\n1400\n1150\nJ Y(St) Y 2x2x0.8\n900\n750\nTIA Category 5\n900\n725\nTP/FT-10 Termination\nTP/FT-10 network segments require termination for proper data transmission\nperformance. The type of terminator varies depending on whether shielded or\nunshielded cable is used. Free topology and bus topology networks also differ in their\ntermination requirements.\n In a free topology segment, only one termination is required and may be placed\nanywhere on the free topology segment. There are two choices for the termination:\nan RC network (Figure 7), with Ra = 52.3Q ±1%, 1/8W, or an LPI-10 Link Power\nInterface, with the LPI-10 jumper at the “1 CPLR\" setting.\nThe Control Network Protocol\n37",
    "Page_38": "Ra\nW\nCa\nCb\nUnshielded\n100uF\n100uF\nTwisted Pair\n50Vmin\n十\n50Vmin\n(UTP)\n.\nNotes:\nCa and Cb are typically aluminum-electrolytic type for improved\nlongevity in the presense of ESD—observe polarity.\n Ca and Cb are required for connection to link power networks.\nFigure 7 TP/FT-10 Termination RC Circuit\n In a doubly terminated bus topology, two terminations are required, one at each end\nof the bus. There are two choices for each termination: an RC network (Figure 7),\nwith Ra = 105Q ±1%, 1/8W, or an LPI-10 Link Power Interface, with the LPI-10\njumper at “2 CPLR\" setting. Only one LPI-10 interface is supported per segment.\nThe LPI-10 contains one of the two required terminators. The other terminator must\nbe an RC-type as shown in Figure 7.\nWhen using shielded twisted pair, the twisted pair must be terminated according to\nthe guidelines listed in the previous paragraphs. In addition, the cable shield must\n be grounded, as shown in Figure 8. The cable shield should be grounded using a\n capacitor to tie the shield to earth ground, and a large-value resistor to bleed off any\nstatic charge on the shield.\nTwistedPair\nTerminationCircuit\nRa\n一\nW\nShielded\nCa\nCb\nTwistedPair\n100uF\n100uF\n1\n(STP)\n50Vmin\n50Vmin\nShield\nGrounding|\nRb\nCC\nCircuit\n1\nThe shield is tied to earth ground through a capacitor, instead of a direct connection,\nin order to avoid DC and 50/60 Hz ground paths from being formed through the\nshield. Typical values for Rb and Cc are as follows:\nCc = 0.luF， l0%， Metalized Polyester，≥ loov\nThe Control Network Protocol\n38",
    "Page_39": "Rb = 470kQ， 1/4W， ±5%\nThe cable shield should be grounded at least once per segment, and preferably at\neach device.\nPL-20 Power Line\nThe easiest channel to install in a utility, home, or transportation system is one that\ncommunicates on the existing power line wiring in the power grid, home, or vehicle.\nPower line devices can simply be plugged into a power outlet with no further wiring\nrequired. The PL-20 channel type uses transceivers that conform to the ISO/IEC\n14908-3 Control Network Power Line (PL) Channel Specification. They also comply\nwith worldwide power line signaling regulations, including FCC, Industry Canada,\nJapan MPT, and European CENELEC EN50065-1 regulations. Worldwide\ncompliance means that PL-20 transceivers can be used in applications worldwide.\nThe European CENELEC communications protocol is automatically managed by\nPL-20 transceivers, eliminating the need for users to develop the complex timing and\naccess algorithms mandated under CENELEC EN50065-1 (the PL-20C channel\ntype). Additionally, PL-20 transceivers can operate in either the CENELEC utility\n(A-Band—the PL-20A channel type) or general signaling (C-Band—the PL-20C\nchannel type with CENELEC access control or PL-20N without) bands, eliminating\nthe need to stock multiple parts for different applications. These transceivers use\nnarrow-band signaling over a 115kHz-132kHz frequency band on power mains\nmedia and support a 5.4kbps raw bit rate in C-Band, and a 75kHz-86kHz frequency\nband on power mains media and support a 3.6kbps raw bit rate in A-Band.\nPL-20 transceivers offer the most robust, lowest cost means of communicating over\nAC or DC power lines using low, medium, or high voltage. Echelon offers a PL-20\nnarrow-band power line transceiver, a Neuron core for running applications and\nmanaging network communications, a choice of on-board or external memory, and an\nextremely small form factor-all at a price that is compelling for even the most\ncost-sensitive consumer product applications.\nPL3150-L10\nECHELON\nA99AA0220\nFigure 9 PL 3120 and 3150 Smart Transceivers\n PL-20 transceivers offer unmatched communication reliability. They use a\nsophisticated digital signal processing core employing patented noise cancellation\nand distortion correction algorithms. These features enable the transceivers to\ncorrect for a wide variety of impediments to power line signaling, including impulsive\nThe Control Network Protocol\n39",
    "Page_40": "noise, continuous tone noise, and phase distortion. The result—Echelon's PL-20\nA unique dual carrier frequency feature automatically selects an alternate secondary\ncommunication frequency should the primary frequency be blocked by noise. The\ntransceivers use a highly efficient, low-overhead forward error correction (FEC)\nalgorithm in addition to a cyclical redundancy check (CRC) to overcome packet\nerrors. PL-20 transceivers have a dynamic range of > 80dB so that on a quiet line\nthe transceivers can receive signals that have been reduced by a factor of 1oo,000.\nA-Band\nC-Band\n75kHz86kHz\n115kHz132kHz\nFigure 10 PL-20 Carrier Frequencies\nThe Echelon PL-20 transceivers are a field-tested, proven technology. The\nunderlying core technology used in the Echelon PL-20 transceivers was developed\nand optimized through years of field-testing in applications worldwide. Millions of\nEchelon narrow band transceivers have been deployed in a wide range of consumer,\nutility, building, industrial, and transportation applications.\nPL-20 Coupling Circuits\nThere are two methods of coupling a PL-20 transceiver to the power line:\nline-to-neutral coupling and line-to-earth coupling. These two methods, combined\nwith two sets of carrier frequencies, define three multiple power line channel types\nreferred t0 as PL-20C(L-N), PL-20N(L-N), PL-20C(L-E), PL-20N(L-E) and\nPL-20A(L-N). The PL-20C(L-N), PL-20N(L-N), and PL-20A(L-N) channel types use\nline-to-neutral coupling, and the PL-20C(L-E) and PL-20N(L-E) channel types use\nline-to-earth coupling. Most installations will consist of devices that use only one\nchannel type in order to achieve maximum communication reliability. However,\nPL-20C(L-N) and PL-20C(L-E) devices may be mixed within an installation with the\npossibility of significant loss (2 - 20dB) of communication margin between L-N and\nL-E devices depending on physical location and power line environment, as can PL-\n20N(L-N) and PL-20N(L-E). PL-20C and PL-20N devices cannot be mixed within an\ninstallation.\nThe PL-20C(L-N), PL-20N(L-N), and PL-20A(L-N) channel types specify coupling\ncircuits that transmit and receive the power-line communications signals between\nthe line and neutral mains conductors. Line-to-neutral coupling is typically used\nexcept when not permitted by local regulations.\nThe PL-20C(L-E) and PL-20N(L-E) channel types specify coupling circuits that\ntransmit and receive the power-line communications signals between the line and\nearth mains conductors.\nPL-20 Specifications\nTable 6 lists the transmission specifications for the PL-20 power line channels.\nThe Control Network Protocol\n40",
    "Page_41": "Table 6PL-20 Power Line Specifications\nParameter\nPL-20(L-N)\nPL-20(L-E)\nPL-20A(L-N)\nCoupling Technique\nLine-to-neutral\nLine-to-earth\n Line-to-neutral\nBit Rate\n 5kbps\n3600bps\nModulation\nBPSK\n Frequency Band\n125kHz-140kHz\n70kHz-95kHz\nOutput Level\n≤ 116dBμV per EN50065-1 for Class 116 EN50065-1 compliance\n≥115dBμV per EN50065-1 otherwise\nOutput Impedance\nZ|≤60\n|Z|≤8Q, 120VAC\n|Z|≤1.1Q\n129kHz-134kHz\n|Z|≤15Q, 240VAC\n70kHz-95kHz\n129kHz-134kHz\nInput Impedance \n≥100Q\n125kHz-140kHz\n≥500Q 70kHz-95kHz\n Input impedance of transceiver and associated coupling circuit only. It does not include effect, if any, of system\npower supply.\nLayer 2- Link Layer\nThe link layer defines media access methods and data encoding to ensure efficient\nuse of a single communications channel. The raw bits of the physical layer are\nbroken up into data frames. The link layer defines when a source device can\ntransmit a data frame, and defines how destination devices receive the data frames\nand detect transmission errors. A priority mechanism is also defined to ensure\n delivery of important messages.\nWhen a device has a message to send, the link layer protocol defines the timing of\nwhen the message is transmitted. Prior to transmitting a message, each device waits\nfor the communications channel to become idle. Because multiple devices may be\nwaiting simultaneously for the channel to become idle, each device waits for a\nrandom interval prior to transmitting. If another device starts transmitting during\nthe waiting interval, the process is repeated. A unique CNP feature is that the\nnumber of randomizing slots increases as network load increases. This feature\nensures reliable sustained network performance, even for networks that are heavily\nloaded.\nMedia Access\nCNP uses a unique media access control (MAC) algorithm that enables an overloaded\nchannel to operate close to its maximum capacity. Other MAC algorithms tend to\ndegrade near maximum capacity due to excess collisions consuming the available\nbandwidth.\nMany different MAC algorithms exist in networks today. The three most common\nare token ring, token bus, and carrier sense multiple access (CSMA). The MAC\nalgorithm used by CNP belongs to the CSMA family.\nThe Control Network Protocol\n41",
    "Page_42": "Token Ring\nThe token ring MAC algorithm ensures orderly access to a communications channel\nby passing a token in an orderly fashion between each device on the channel. To\nensure that only one device has the token at a time, the devices are linked in a daisy\nchain ring. This algorithm is not well suited to control applications for the following\nreasons:\n It is not suitable for open media such as power line, RF, or infrared because all\nstations receive the token simultaneously and cannot be linked in a ring.\n It increases the cost of each device in a control network because every device\nrequires additional hardware to recover the token when it is lost and to ensure\nthe continuity of the ring.\n In an existing network, it is disruptive to add new devices or replace existing\nones. The ring must be broken to add or change a device, temporarily bringing\ndown the entire network.\n· Message latency increases as devices are added to a channel.\nToken Bus\nA token bus architecture solves the problem of sequential passing of a MAC token by\nincluding addressing information in the token. However, at low data rates, the\nprocess of circulating the token can result in considerable token latency. Because a\n device cannot transmit without first possessing the token, this latency adversely\naffects response time, which is a key parameter for control networks.\nAdditionally, token bus systems must reconfigure themselves each time a new device\neither becomes active or drops out. This overhead to reconfigure is a problem for all\ntoken bus networks. Because reconfiguration brings the network down for its\nduration, battery-powered devices whose normal operation is to wake up, send some\nmessages, and power down, would cause the token bus system to suffer frequent\nreconfigurations. Battery-powered devices are required for applications needing RF\n or IR communication, for security applications, and for fire/life safety applications, to\nname a few.\nCarrier Sense Multiple Access (CSMA)\nThe CSMA family of MAC algorithms is better suited for control networks than token\nring or token bus. The CSMA algorithms require a device to establish that the\nmedium is idle before it begins to transmit. However, each algorithm behaves\ndifferently once the idle state is detected. This results in very different network\nperformance results under conditions of heavy data traffic.\nSome CSMA algorithms use discrete intervals of time called slots, or randomizing\nspecific time slots, slotted media access greatly reduces the probability of two packets\ncolliding. The most common form of slotted media access is p-persistent CSMA. In\np-persistent CSMA, when a device has a message to send, it does so in a given\nrandomizing slot with probability p. This algorithm is used by many popular CSMA\nprotocols.\nThe Control Network Protocol\n42",
    "Page_43": "The link layer protocol for Ethernet as defined by IEEE 802.3 uses a degenerate form\nof p-persistent CSMA called 1-persistent CSMA. This version of CSMA depends on\ncollision detection which is not practical on many communications media used by\ncontrol networks.\nControl networks may consist of thousands of devices and multiple media on a single\nnetwork. Because of the characteristics of different communications media and the\npotential need to cover large distances, LoNWoRKS networks must be able to support\nhigh-speed and low-speed channels, which may occasionally carry traffic approaching\nthe channel's capacity. CSMA/CD (for example IEEE 802.3) behaves poorly during\n periods of overload, so it is generally not used for control applications. P-persistent\nCSMA works very well for small values of p (that is, many randomizing slots) at the\nexpense of additional delay during relatively idle periods.\nThe CSMA family of MAC algorithms does not require a ring topology,\nsynchronization or reconfiguration, and does permit new devices to be added or\nexisting devices to drop out and rejoin the network transparently. Additionally, it\nsupports many devices and is inexpensive to implement in hardware. The CNP MAC\nalgorithm has the advantages of p-persistent CSMA without the disadvantages of\nadditional delay during low traffic, significantly reduced throughput under conditions\nof high traffic, or the requirement for expensive collision detect hardware.\nPredictive P-Persistent CSMA\nCNP uses a variant of the p-persistent CSMA MAC algorithm called predictive\n p-persistent CSMA. CNP retains the benefits of CSMA but overcomes its\nshortcomings for control applications. Existing media access control algorithms such\nas IEEE 802.2, 802.3, 802.4, and 802.5 do not meet all the CNP requirements for\nmultiple communication media, sustained performance during heavy loads, and\nsupport for large networks.\nAs in p-persistent CSMA, all LoNWoRKS devices randomize their access to the\nmedium. This avoids the otherwise inevitable collision that results when two or\n more devices are waiting for the network to go idle so that they can send a packet. If\nthey wait for the same duration after backoff and before retry, repeated collisions will\nresult. Randomizing the access delay reduces collisions. In CNP, devices randomize\n different levels of delay called beta 2 slots, shown in Figure 11.\nPacket Cycle\nPacket\nBeta 2 Slots\nFigure 11 Beta 2 Slots\nIn p-persistent CSMA when a device has a message to send, it does so in a given\nrandomizing slot with probability p. However, CNP carries the added improvement\nthat pis dynamically adjusted based upon network load. When the network is idle,\nall devices randomize over 16 beta 2 slots. Thus the average delay in an idle network\nThe Control Network Protocol\n43",
    "Page_44": "is eight slot widths. When the estimated network load increases, devices may\nrandomize over a larger number of beta 2 slots. The number of slots increases by a\nfactor of n, where the range of nis from 1 to 63. Therefore, the maximum number of\nbeta 2 slots is 63 * 16, or 1008. In CNP, nis called the estimated channel backlog. It\nrepresents the number of devices with a packet to send during the next packet cycle.\nThis method of estimating the backlog and dynamically adjusting the media access\nallows CNP to have a small number of beta 2 slots during periods of light load, while\nhaving the benefit of many beta 2 slots during periods of heavy load. Thus, media\naccess delays are minimized during periods of light load, and collisions are minimized\nduring periods of heavy load.\nThe ability to adjust the number of beta 2 slots depends on the ability to estimate the\nchannel backlog. In CNP, a transmitting device includes information in the packet\non the number of acknowledgements expected as a result of sending that packet. All\nthe devices that receive the packet increment the estimated channel backlog by that\namount. Likewise, the estimated channel backlog is decremented by 1 at the end of\neach packet. The estimated channel backlog is never decremented below 1. Because\nCNP packets are frequently acknowledged, even when the destination is a group of\ndevices, 50% or more of the channel backlog is predictable at any time.\nIn summary, the CNP MAC algorithm specifically overcomes the shortcomings of\nexisting MAC algorithms using a unique collision avoidance mechanism. To avoid\ncollisions, all LoNWoRKs devices randomize their access to the communication\nmedium using time slots. CNP dynamically adjusts the number of time slots by\npredicting the channel backlog. By actively managing the collision rate, CNP\nprovides a superior MAC algorithm that is not dependent on collision detection\nhardware.\nPriority\nA key requirement of control networks is timely response to priority messages. CNP\nincludes an optional priority mechanism to improve the response time of critical\npackets. When a device tries to access the communication medium, priority\nmessages are given earlier access than non-priority messages. The protocol permits\nthe network management tool to allocate a fixed number of beta 2 slots per channel\nas priority time slots dedicated to priority devices. The number of priority slots can\nbe from 0 to 127. The network management tool that assigns priority slots to\nindividual devices can ensure that one and only one device is assigned to a particular\npriority slot on the channel. Each priority time slot on a channel adds a minimum of\ntwo bit times to the transmission of every message. The amount of overhead will\nvary based upon the bit rate, oscillator accuracy, and transceiver requirements. For\nexample, using a TP/XF-1250 1.25Mbps twisted pair transceiver with all devices on\nthe channel having an oscillator accuracy of 0.02% (200ppm) or better, each priority\nslot is 30 bit-times wide. Because there is no contention for the media during the\n priority portion of a packet cycle, devices configured with priority have better\nresponse time than non-priority devices.\nFigure 12 illustrates priority and non-priority beta slots. The value m is the number\nof priority slots. It is controlled by the network management tool used to install the\ndevices on a channel. Its value may be zero to 127. The value nis the number of\nnon-priority slots. It is calculated by each device on a channel and may be any value\nfrom 16 to 1008 - m.\nThe Control Network Protocol\n44",
    "Page_45": "Packet Cycle\n//\n1|2|3 .. [m|1|2|3|...\nPacket\nn\nPacket\nPriority Slots   Non-priority Slots\nFigure 12 Beta 2 Slots With Priority\nThe priority slot assigned to a device applies to all priority packets sent from that\ndevice. One, all, or some of the packets sent from a device may be marked as using\npriority service. The priority designation within a device is made on a per network\nvariable or per message tag basis, and may be set at compile time. In the case of \nnetwork variables, the priority designation can optionally be changed during or after\ninstallation.\nLower priority numbers indicate higher levels of priority: a priority packet from a\n device assigned priority slot 2 will be transmitted before a priority packet from a\n device assigned priority slot 4. Setting a device's priority to 0 indicates that none of\nits packets will be transmitted in a priority slot, regardless of the message service\nassignment made at device compilation or installation time. Slot 1 is reserved for a\nnetwork management tool, to ensure that no application can render a channel\nincapable of interruption by a network management tool. Slots 2 through 127\n(depending on the medium, and the number of slots allocated on the channel) are\nthen available for prioritized packets from designated devices.\nWhen a priority packet is generated within a device, it travels out of the device on a\npriority queue, ahead of any pending non-priority packets buffered for transmission.\nSimilarly, when a priority packet reaches a router, it goes to the head of the router\nqueue (behind any other queued priority packets) and is forwarded to the far channel\nusing the router's priority slot if one has been configured.\nThe effectiveness of priority depends on all devices preparing to send a message\nbeing synchronized on the end of the previous packet. When the sending devices are\nsynchronized, then the priority time slots remain uncontested. Priority assignment\nhas two limitations: (i) a maximum of 126 devices per channel may be assigned\npriority; and (ii) reserving time slots pre-allocates bandwidth. The first limitation is\nnot a factor for channels that support fewer than 126 devices. For a TP/XF-78\ntwisted-pair transceiver using interoperable communications parameters, each\npriority slot is 5.6 bit times wide. Using a TP/XF-1250 twisted-pair transceiver with\ninteroperable communications parameters the priority slots are 30 bit times wide. In\neffect, the length of each non-priority packet is increased by the time required for\npriority slots, thus using up channel bandwidth.\nFrame Format\nWhen a device has a message to send, it uses the MAC algorithm to decide when to\nsend it. When the device sends the message, the bits within the message are encoded\nas a frame. The frame has the following components: the preamble, link layer\nheader, network layer datagram, CRC, and end-of-packet indicator. A CNP frame\nhas the following format (bit-sync is a variable number of bits, but must be at least 6\nbits long):\nThe Control Network Protocol\n45",
    "Page_46": "msb\nIsb\nBit-sync (configurable number of 1 bits)\n0\nPri\nPath\nDelta Backlog\nNetwork Layer Datagram (6 to 246 bytes)\nCCITT CRC-16 (2 bytes)\nFigure 13 illustrates the physical encoding of a CNP frame on the communications\nchannel.\nData\nY\nTransmit\nEnable\n\"—\"→\nBit Sync\n一\n'Byte\nData + 16 bit CRC\nLine-Code \nBeta 1Beta 2\nS ync\nPreamble\nViolation\nFigure 13 Packet Timing\nFor differential and single-ended modes, the transmitter transmits a preamble at the\nbeginning of a packet to allow the other devices to synchronize their receiver clocks to\nthe transmitter's clock. The use of a preamble allows every device on a channel to\nhave an asynchronous clock. The preamble allows devices with independent clocks to\nsynchronize their bit and byte sampling times.\nThe preamble consists of a bit-sync field and a byte-sync field. The bit-sync field is a\nseries of Differential Manchester 1's; its duration is set to the same value for every\ndevice on a channel and is at least six bits long. The byte-sync field is a single bit\nDifferential Manchester O that marks the end of the preamble, and immediately\nprecedes the beginning of the first byte of the packet.\nThe frame is terminated with an idle period on the channel. An idle period is\nindicated by a lack of transitions on the channel for longer than 2 bit times. For\ndifferential and single-ended modes, the transmitter indicates the end-of-packet by\nforcing a Differential Manchester line-code violation; that is, it holds the data output\nthe end of transmission. The data output can be either high or low for the duration\nof the line-code violation, depending on the state of the data output after\ntransmitting the last bit. The line-code violation begins after the end of the last CRC\nbit and lasts for at least 2 bit times. The last bit does not have a trailing clock edge,\nso the data output actually remains transitionless for at least 2.3 bit times.\nFor special purpose mode, the preamble and end-of-packet indicator are managed by\nthe transceiver. The preamble and end-of-packet indicator may be similar to those\nused by differential and single-ended modes, but is not required to be the same.\nThe Pri field specifies the priority of the frame. A value of O is used for non-priority\nframes, and a value of 1 is used for priority frames.\nThe Path field specifies the channel to use for special purpose mode transceivers. A\nspecial purpose mode transceiver can be interfaced to two physical channels or to two\nphysical bit encodings on the same channel. This allows error recovery by switching\nThe Control Network Protocol\n46",
    "Page_47": "to an alternate channel if message transmission on the primary channel fails. A\nvalue of 0 is used for the primary channel and a value of 1 is used for the alternate\nchannel. The transport layer specifies the alternate channel for the last two retries\n of an acknowledged message.\nThe Delta Backlog field specifies a channel backlog increment. Receiving devices add\nthis value to their backlog estimate to account for transmission of this frame.\nThe CRC field is a 16-bit CRC computed using the CCITT CRC-16 standard\npolynomial, which is X16 + X12 + X5 + 1. The polynomial is computed over the entire\n packet and link layer header.\nLayer-2 Performance\nCNP Predictive p-Persistent CSMA Performance\nThe CNP predictive algorithm works best when a majority of the CNP packets on a\nchannel are acknowledged. The number of acknowledgements that a given packet\ngenerates is encoded into each acknowledged packet. Each device on the channel\nreceives all the acknowledged packets on the channel and adds the number of\nacknowledgements to the channel backlog. If none of the packets is acknowledged,\nthe predictive part of the algorithm does not dynamically expand the number of\nservices causes CNP to behave like a non-predictive p-persistent CSMA where p =\n0.0625. However, even this degenerate case is still significantly better than IEEE\n802.3 (which is a p-persistent CSMA protocol where p = 1) under conditions of heavy\nnetwork traffic.\n1200\n1100\nThroughput vs\n1000\nCollision Rate\n006\nC\n800\no\n004\n12\npac kets/ s600\n500\n400\n。\n00\nn\n200\nS\n100\n7515022530037545052560067575082590097510501251200\nOffered Traffic\n L Throughput  L Throughput  Collision Rate\nFigure 14 Effective Network Throughput vs. Offered Traffic Using Unacknowledged Services\nThe results of two benchmarks used to illustrate this point are shown in Figure 14\nand Figure 15. The graphs shown in these figures illustrate results achieved from a\nother two acted as test devices, repeatedly sending messages to each other at\nThe Control Network Protocol\n47",
    "Page_48": "different traffic levels. Both graphs show the amount of actual traffic that got\nthrough on the network versus the offered traffic, or the number of packets\nattempted for transmission.\nFigure 14 shows this data using exclusively unacknowledged packets. In this mode,\nthe network behavior is similar to a 0.0625-persistent CSMA algorithm. The graph\nshows how the network throughput is nearly proportional with offered traffic and up\nto 1200 packets/sec.\n1100\n100\nT\nThroughput vs\n900\nCollision Rate\nB00\n700\n600\nZT\npackets's\n500\n400\ni\n300\nSaturation Point\nn\n200\n100\n150\n225\n方\n525\n600\nSL9\n0SL\n625\n900\noffered traffic (packets s)\nnduan EI \nn\nCollision Eate\nFigure 15 Effective Network Throughput vs. Offered Traffic Using Acknowledged Services\nTo demonstrate the effectiveness of the predictive algorithm, the experiment was\nre-run with only one change. In this case, messages used acknowledged services.\nFigure 15 shows the data derived from this experiment. The graph shows that\nnetwork throughput degrades slightly with an increase in offered traffic past the\nsaturation point.\nFigure 14 and Figure 15 illustrate how the collision rate grows slowly, even past the\nchannel saturation point. This active management of the collision rate is what\nmakes the CNP predictive p-persistent CSMA algorithm superior to other CSMA\nalgorithms.\nMedia Access Delay and Offered Traffic\nWhen a device on a network tries to send a message, it must first wait for the\nmedium to be idle. The time delay between when a device queues the packet to send\nand the time that it is actually sent on the network plays a role in the response time\nof that message. This delay is known as the media access delay. As the offered\ntraffic (the total number of packets per second offered for transmission by all the\n devices on a channel) on a given channel of a network increases, the media access\n delay increases. In networks loaded to near-capacity, when many devices are trying\nto send messages, this delay can be significant. In designing a network to meet\nspecified response times, the worst-case offered traffic must be considered and\ndesigned for.\n Following is an example of assessing the impact of media access delay: For an\nis 112 bits (14 bytes), and the average number of bit times between each packet is 48.\nThe amount of time a typical message spends on the media is 183.5 (= 23.5 + 112 +\n48) bit times on the channel. The maximum rate at which packets can be sent on\nThe Control Network Protocol\n48",
    "Page_49": "this channelis therefore 425 packets (=78125/183.5) per second, and each packet\ncycle requires 2.3ms.\nFor this example, if a device on this network requires a maximum response time\nrequirement of 50 ms, we must set a bound on the offered traffic to limit the media\naccess delays. At 78 kbps with 183.5 bit packet cycles it takes this network 50 ms to\nsend 25 packets. If the packets on the channel may be sent at any time, including all\nat once, then, in order to always meet the requirement of 50 ms without using any\nspecial priority features, the channel should never have an offered traffic greater\nthan 21 packets per second. As this example illustrates, the response time\nrequirements of devices on a network must be used to design the network and ensure\nthat the offered traffic does not cause unacceptable media access delays\nLayer 2 Channel Throughput\nLayer 2 channel throughput depends on the bit rate, oscillator frequencies and\naccuracy, transceiver characteristics, average packet size, and the use of\nacknowledgments, priority, and authentication on the channel. An average packet is\nin the range of 10 to 16 bytes long, depending on the length of the domain identifier,\nthe addressing mode, and size of the data field. The maximum packet size is 249\nbytes including data, addressing, and protocol overhead.\nAt low bit rates or with long packets, channel throughput is bounded by the packet\ntransmission time and average media access delay. At higher bit rates with short\n packets, the packet processing power of the Neuron core limits channel performance.\nTable 7 and Table 8 estimate the approximate network throughput as a function of\nbit rate and packet size. The “peak\" traffic numbers can be supported for short\nbursts.\nTable 7 CNP Channel Throughput With 12-byte Packets\nPeak Number\nSustained Number\nBit Rate (kbps)\nof Packets/Sec\nof Packets/Sec\n4.883\n25\n20\n9.766\n45\n35\n19.531\n110\n85\n39.063\n225\n180\n78.125\n400\n320\nThe Control Network Protocol\n49",
    "Page_50": "Table 8 CNP Channel Throughput With 64-byte Packets\nPeak Number of\nSustained Number\nBit Rate (kpbs)\nPackets/Sec\nof Packets/Sec\n4.883\n7\n5\n9.766\n13\n10\n19.531\n25\n20\n39.063\n50\n40\n78.125\n100\n80\nLayer 3- Network Layer\nThe network layer defines how message packets are routed from a source device to\none or more destination devices. This layer defines naming and addressing of devices\nto ensure the correct delivery of packets. Messages can be addressed to a single\ndevice, to any group of devices, or to all devices. Group addressing reduces network\ntraffic by supporting the delivery of a single message packet to multiple devices.\nThis layer also defines how messages are routed between the source and destination\ndevices when these devices are on different communication channels. Addresses are\nformed using a hierarchical structure which supports the use of routers that filter\nmessages based on their destination address. By supporting routers at the network\nlayer, CNP supports the installation of very large systems with thousands of devices.\n Routers use the network layer to confine traffic to segments within a large network,\nthereby increasing total capacity of the network.\nNaming and Addressing\nA name is an identifier that uniquely identifies a single object within an object class.\nA name is assigned when an object is created and does not change over its lifetime.\nTo ensure that every LoNWoRKs device can be uniquely distinguished from every\nother LoNWoRKS device, every Neuron core includes a unique 48-bit ID called the\nNeuron ID. This ID will always be unique for every Neuron core and does not change\nover the lifetime of the Neuron core.\n An address is an identifier that uniquely identifies an object or group of objects\nwithin an object class. Unlike a name, an address may be assigned and changed any\ntime after an object is created.\nCNP addresses uniquely identify the source device and destination device (or devices)\nof a CNP packet. These addresses are also used by intelligent routers to selectively\npass packets between two channels.\nA Neuron ID may be used as an address. However, the Neuron ID is not used as the\nsole form of addressing in CNP because such addressing only supports one-to-one\ntransactions (that is, no groups), complicates device replacement, and would require\nexcessively large routing tables and time-consuming processing to optimize network\ntraffic. This addressing mode is used primarily during installation and\nThe Control Network Protocol\n50",
    "Page_51": "configuration, because it allows communications with a device before the device has\nbeen assigned an address.\nTo simplify routing, CNP defines a hierarchical form of addressing using three\naddress components: the domain, subnet, and node addresses. This form of\naddressing can be used to address an individual device or collections of devices\nsharing common subnet or domain address components. To further facilitate the\naddressing of multiple dispersed devices, CNP defines another class of addresses\nusing domain and group addresses.\nThe use of a dynamically assigned address instead of a fixed name simplifies\nreplacement of devices in a functioning network. The replacement device is assigned\nthe same address as the device it replaces. Thus all references to this device from\nelsewhere on the network do not need to be modified, as would be the case if Neuron\nID addressing were to be used.\nThe various address forms are described in the following sections, along with\ndiscussions on routers and address generation.\nThe Domain Address Component\nA domain is a logical collection of devices on one or more channels. Communications\ncan only take place among devices configured in a common domain; therefore, a\ndomain forms a virtual network. Multiple domains can occupy the same channels, so\ndomains may be used to prevent interference between devices in different networks.\nFor example, two adjacent buildings using devices with power line transceivers on\nthe same frequency may be on the same channel. To prevent interference between\nthe applications carried out by the devices, the devices in each building would be\nconfigured to belong to different domains.\nThe Neuron core may be configured so that it belongs to one or two domains. A\n device that is a member of two domains may be used as a gateway between the two\n domains. CNP does not support communications between domains, but an\napplication program may be implemented to forward packets between two domains.\nA domain is identified by a domain ID. The domain ID may be configured as O, 1, 3,\nor 6 bytes. Six byte domain IDs can be used to ensure that the domain ID is unique:\nfor example, using the 48-bit Neuron ID of one of the Neuron cores in the domain as\nthe domain ID ensures that no other network can have the same domain ID, because\nall Neuron IDs are unique. However, six byte domain IDs add six bytes of overhead\nto every packet. The overhead may be reduced by using a shorter domain ID. In a\nsystem where there is no possibility of interference between multiple networks, the\ndomain ID may be configured as 1 byte (zero byte domain IDs are supported by CNP,\nbut reserved for administrative purposes). Domain IDs may be configured as 1 or 3\nbytes in systems where a single administrator controls assignment of domain IDs to\nprevent duplicate IDs.\nThe domain ID can also be used for application-level purposes. For example, a\ndomain ID could be used by service personnel as a system identifier.\nThe Control Network Protocol\n51",
    "Page_52": "The Subnet Address Component\nA subnetis a logical collection of up to 127 devices within a domain. Up to 255\nsubnets can be defined within a single domain. All devices in a subnet must be on\nthe same segment (subnets cannot cross intelligent routers). Figure 16 illustrates six\n devices installed in two subnets. The six devices are physically attached to the same\ncommunications channel.\nChannel\nDevice 1\nDevice 2\nDevice 3\nDevice 4\nDevice5\nDevice6\nSubnet 1\nSubnet 2\nFigure 16 Multiple Subnets on a Single Channel\nFigure 17 illustrates seven devices installed in two subnets. The seven devices are\nphysically attached to two communications channels. The two channels are on a\ncommon segment because they are connected by a repeater.\nChannel 1\nDevice1\nDevice2\nDevice3\nDevice4\nDevice5\nRepeater\nSubnet1\nChannel2\nDevice6\nDevice7\nSubnet2\nFigure 17 Two Subnets on a Common Segment\nFigure 18 illustrates a network with a router. An additional subnet is required\nbecause subnets cannot cross intelligent routers.\nThe Control Network Protocol\n52",
    "Page_53": "Channel 1\nDevice 1\nDevice 2\nDevice3\nDevice4\nDevice5\nRouter\nSubnet 1\nSubnet2\nChannel2\nDevice6\nDevice7\nSubnet 3\nFigure 18 Three Subnets on Two Segments\nIf a device is configured to belong to two domains, it must be assigned to a subnet\nwithin each of the domains. Device 4 in Figure 19 is a member of two domains, and\nis assigned to subnet 1 in both domains. The subnet numbers do not have to match\nin the two domains.\nChannel\nDevice 1\nDevice 2\nDevice 3\nDevice 4\nDevice 5\nDevice 6\nDevice 7\nDISN1\nD1S1N2\nDS1N3\nD2IS1N2\nD2IS1N3\nD2IS1N4\nDomain 1\nDomain 2\nSubnet 1\nSubnet 1\nFigure 19 Device Configured in Two Domains\nAll devices within a domain are typically configured in the same subnet except in the\nfollowing cases:\nThey are located on different segments with intervening intelligent routers.\n Because subnets cannot cross intelligent routers, the devices must be on different \nsubnets.\nConfiguring the devices in the same subnet would exceed the maximum number\nof devices allowed in a subnet. Subnets are limited to 127 devices. Multiple\nsubnets may be configured on a segment to increase the capacity of the segment\nabove 127 devices (up to the limit of the channel used by the subnet). For\nexample, a segment with two subnets may have up to 254 devices; three subnets\nmay have up to 381 devices; and so on.\nThe Node Address Component\nEvery device within a subnet is assigned a unique node ID within that subnet. The\nnode ID is 7 bits, so there may be up to 127 devices per subnet. A maximum of\n 32,385 devices (255 subnets x 127 devices per subnet) may be in a single domain.\nThe Control Network Protocol\n53",
    "Page_54": "Each configured device can be uniquely identified using its combination of domain\nID, subnet ID, and node ID.\nGroups\nA groupis a logical collection of devices within a domain. Unlike a subnet, however,\ndevices are grouped together without regard for their physical location in the domain.\nThe Neuron firmware implementation of CNP allows a device to be configured to be a\nmember of up to 15 groups, other implementations have different limits.\nGroups are an efficient way to use network bandwidth for messages addressed to\nmultiple devices (that is, one-to-many connections). Figure 20 illustrates a network\nwith two groups. Group 1 consists of devices 1, 2, 3, 10, 11, and 12. Group 2 consists \nof devices 3, 4, 5, and 7. Device 3 is in both groups.\nGroup 2\nGroup 1\nChannel1\nDevice 1\nDevice 2\nDevice 3\nChannel 2\nDevce4\nDevice5\nDevice 6\nChannel 3\nDevice7\nDevice 8\nDevice 9\nChannel 4\nDevice 1d\nDevice 11\nDevice12\nFigure 20 Groups Spanning Channels and Routers\n Groups are identified by a one-byte group number, so a single domain may contain\nup to 256 groups. Layer 6 adds another addressing layer on top of the layer-3\naddresses for data points. As a result, it is possible to reuse group IDs when group\nIDs are used in combination with layer-6 addresses.\nNeuron ID\nIn addition to the subnet/node ID address, a device may always be addressed by a\nunique ID call the Neuron ID. The Neuron ID is 48-bits long, and is assigned when\nThe Control Network Protocol\n54",
    "Page_55": "each CNP device is manufactured. This ID is unique worldwide for every CNP\ndevice.\nThe Neuron ID is used by a network tool in the initial configuration of devices at\ninstallation time to assign each device in a network to one or two domains, and to\nassign subnets and node ID numbers. Neuron ID addressing is not used for\napplication messages except in self-installed systems by a user-interface controller.\nAddressing Formats\nCNP devices are addressed using one of five addressing formats. The particular\naddressing format used determines the number of bytes required for the source and\ndestination address. Table 9 defines the formats and number of bytes required for\neach. The total address size is computed by adding the appropriate number of bytes\nindicated in the table to the size of the domain ID, which can range from O to 6 bytes\ndepending on the configured size of the domain ID.\nTable 9 CNP Address Formats\nAddress Size\nAddress Mode\nAddress Format\nDestination\n(bytes)\nDomain-wide Broadcast\nDomain (Subnet = 0)\nAll devices in the\n3\ndomain\nSubnet-wide Broadcast\nDomain, Subnet\nAll devices in the\n3\nsubnet\nMulticast\nDomain, Group\nAll devices in the\n3\ngroup\nUnicast\nDomain, Subnet, Node\nS pecific device within\n4\na subnet\nNeuron ID\nDomain, Neuron ID\nS pecific device\n9\nAddress Table\nEach CNP device contains an address table that contains addressing information\nthat can be managed by a network management tool in a managed network, or by the\nCNP implementation on the device in a self-installed network. A CNP application\ncan specify an address for an outgoing message by referencing an entry in the\naddress table. This type of address is called an implicit address. Alternatively, a\nCNP application can specify the full layer-3 address for an outgoing message. This\ntype of address is called an explicit address.\nThe advantage of implicit addressing is that it eliminates the requirement for a CNP\napplication to manage destination addresses. Layer-3 addresses are typically\nallocated and managed by the network management tool in a managed network or\nthe ISI engine in a self-installed network. The CNP application can send a message\nusing a fixed index into the address table rather than attempting to determine the\nfull layer-3 address for each message.\nThe Control Network Protocol\n55",
    "Page_56": "The advantage of explicit addressing is that it allows a CNP application to send\nmessages to more destination addresses than can be stored in the address table. An\naddress table may contain up to 65,535 entries, but different CNP implementations\nmay have lower limits. The Neuron firmware is limited to a maximum of 15 entries\nin the address table.\nThe address table also specifies the groups that the CNP device belongs to. When an\nincoming group-addressed message is received, the CNP implementation searches\nthe address table for a matching group ID. As a result, the number of entries in the\naddress table for a CNP device is the upper limit on the number of groups that the\n device may be a member of. The limit is reduced by the number of non-group implicit\naddresses stored in the address table.\nR outers\nRouters are infrastructure devices that connect two channels and route packets\nbetween them. Routers can be installed to use one of four routing algorithms:\nRepeater. A repeater is the simplest form of router, simply forwarding all valid\npackets between the two channels. Using a repeater, a subnet can exist across\nmultiple channel segments.\nBridge. A bridge forwards all packets which match its domains between the two\nchannels. Using a bridge, a subnet can exist across multiple channel segments.\nLearning Router. A learning router monitors the network traffic and learns the\nnetwork topology at the domain/subnet level. The learning router then uses its\nknowledge to selectively route packets between channels. Learning routers\ncannot learn group topology, so all packets using group addressing are forwarded.\n Configured Router. Like a learning router, a configured router selectively routes\npackets between channels by consulting internal routing tables. Unlike a\nlearning router, the contents of the internal routing tables are defined by a\nnetwork management tool. A network management tool can optimize network\ntraffic by defining routing tables for both subnet and group address routing\nConfigured routers do not execute the learning algorithm as a learning router\ndoes. Instead, the network management tool pre-configures the router's\nforwarding tables at the time of installation, based on the tool's knowledge of the\nnetwork topology.\nConfigured routers and learning routers are a class of routers known as intelligent\nrouters.\nChoosing Between Learning and Configured Routers\nInitially, each learning router sets its internal routing tables to indicate that all\nsubnets could lie on either side of the router. Figure 21 illustrates a network with\ntwo learning routers. If device 5 generates a message addressed to device 2, channel\n2 will carry the message to learning routers 1 and 2. Examining the source subnet\nfield of the message, learning router 1 notes in its internal routing tables that subnet\n2 lies below it. The router then compares the source and destination subnet IDs.\nBecause they are different, the message is passed on.\nThe Control Network Protocol\n56",
    "Page_57": "Channel 1\nLeaming\nDevice 1\nDevice 2\nDevice 3\n Router 1 \nSubnet1\nChannel 2\nLeaming \nRouter 2 \nDevice 4\nDevice 5\nDevice 6\nChannel 3\nSubnet 2\nDevice 7\nDevice8\nDevice 9\nSubnet3\nFigure 21 Learning Routers\nMeanwhile, learning router 2 has also passed on the message, making an appropriate\nnotation in its internal routing tables regarding the location of subnet 2.\nIf device 2 generates an acknowledgement, the acknowledgement is picked up by\nlearning router 1, which now notes the location of subnet 1. Learning router 1\nexamines its internal routing tables, and, upon discovering that subnet 2 lies below,\n device 5 (the destination device), and learning router 2, who does not pass it on but\nmerely notes that subnet 1, like subnet 2, lies somewhere above. Learning router 2\nwill not learn of the existence or location of subnet 3 until a message is originated\nfrom there.\nConfigured routers should always be used when possible for the following reasons:\n The initial flood of traffic that occurs while a learning router is learning the\nnetwork topology may cause congestion problems.\n The network topology may have inadvertent “loops,” which are common in power\nline and RF networks, that can cause a learning router to develop an inaccurate\nnetwork image.\n Learning routers do not learn about groups but configured routers can be\nconfigured to selectively forward group addressed packets.\nSubnets cannot cross intelligent routers. While bridges and repeaters allow subnets\nto span multiple channels, the two sides of an intelligent router must belong to\nseparate subnets. The fact that intelligent routers are selective about the packets\nthey forward to each channel can be used to increase the total capacity of a system in\nterms of devices and connections. In general, it is always a good idea to segment\ntraffic among “communities of interest\" if possible.\nThe Control Network Protocol\n57",
    "Page_58": "Physical Layer Repeaters\nSome channel types support physical layer repeaters (PLRs). A physical layer\nrepeater receives and forwards packets between two or more ports and can be used to\n overcome a channel's device count or cable length limitations in some cases.\nWhile a physical layer repeater does not forward pure noise (it is not just a\nbi-directional amplifier), PLRs contain no intelligence, and will therefore forward any\n packet, even one that might have been corrupted as result of a collision.\nA router should be preferred to a physical layer repeater, but PLRs offer a low-cost\nalternative to routers in some cases.\nDatagram Format\nThe network layer builds a datagram by adding a network header to a transport\nlayer packet. A CNP datagram has the following format:\nmsb |\n|lsb\nVersion\nPacket\nAddr Format\nLength\nFormat\nAddress (3 to 9 bytes)\nDomain (0, 1, 3, or 6 bytes)\nPacket\nThe Version field defines the CNP version number, and is always 0.\nThe Packet Format field defines the format of the packet enclosed within the\ndatagram, and contains one of the following values:\nPacket Format\nPacket Format\nField\n0\nTransport P acket\n1\nSession Packet\nAuthenticated Packet\n3\nPresentation Packet\nThe packet formats are defined in chapters 5, 6, and 7.\nThe Addr Format field defines the format of the address contained within the\ndatagram and contains one of the following values:\nAddrFormat\nAddress Format\nField\n0\nSubnet Broadcast\n1\nGroup\n2\nSubnet/Node or Group\nAcknowledgement\n3\nNeuron ID\nThe Address field contains the network address for the message. The format of the\naddress is defined by the Addr Format field. A Subnet Broadcast address has the\nfollowing format:\nThe Control Network Protocol\n58",
    "Page_59": "msb\nIsb\nSource Subnet\nSource Node\nDestination Subnet\nA Group address has the following format:\nmsb\nIsb\nSource Subnet\nSource Node\nDestination Group\nA Subnet/Node address has the following format:\nmsb\nIsb\nSource Subnet\n1\nSource Node\nDestination Subnet\n1\nDestination Node\nA Group Acknowledgement address has the following format:\nmsb\nIsb\nSource Subnet\n0\nAcknowledged Member\nDestination Subnet\n1\nDestination Node\nAcknowledged Group\nA Neuron ID address has the following format:\nmsb\nIsb\nSource Subnet\nSource Node\nDestination Subnet\nNeuron ID (6 bytes)\nThe Length field defines the length of the domain field, and contains one of the\nfollowing values:\nLength Field\n Domain Length (bytes)\n0\n0\n1\n1\n2\n3\n3\n6\nLayer 4- Transport Layer\nThe transport layer ensures reliable delivery of message packets. Messages can be\nexchanged using an acknowledged service, where the sending device waits for an\nacknowledgement from the receiver or receivers and resends the message if the\nacknowledgement is not received. The application is informed if an\nacknowledgement is not received after a configurable number of retries. The\nThe Control Network Protocol\n59",
    "Page_60": "transport layer also defines how duplicate messages are detected and rejected if a\nmessage is resent due to a lost acknowledgement. Messages that do not require the\nreliability of acknowledged service can use unacknowledged or repeated services to\nsend the message once, or a configurable number of times, without waiting for an \nacknowledgement.\nMessage Services\nCNP offers four basic types of message service: acknowledged, request/response,\nrepeated, and unacknowledged. The acknowledged, repeated, and unacknowledged\nservices are managed by the transport layer. The request/response service is\nmanaged by the session layer. These services provide a tradeoff between reliability\nand efficiency.\nThe most reliable service is acknowledged, or end-to-end acknowledged service,\nwhere a message is sent to a device or group of devices and individual\nacknowledgements are expected from each receiver. If an acknowledgement is\nnot received from all destinations, the sender times out and retries the\ntransaction. The number of retries and the time-out are both selectable (see CNP\nTimers, later in this document). Transaction IDs are used to keep track of\nmessages and acknowledgements so that the application does not receive\nduplicate messages.\n An equally reliable service is repeated, also called the unacknowledged repeated\n service, where a message is sent to a device or group of devices multiple times,\nmore than a few devices, because the number of packets required to repeat the\ntransmission will be less than the number of packets required for all the\n acknowledgements. For example, if a device sends an acknowledged message\nwith four retries to five devices, there will be a minimum of six packets-the\noriginal message plus five acknowledgements. If the same message was sent\nwith the repeated service with a repeat count of four, only four packets would be\nrule-of-thumb is to use repeated service instead of acknowledged service\nwhenever the size of the group is larger than the retry count. The exception to\nthis rule is if the sending application needs notification of delivery failure, in\nwhich case acknowledged service should be used. This is typically only required\nif the sending application can take alternative action in case of delivery failure.\nThe least reliable is unacknowledged, where a message is sent once to a device or\ngroup of devices and no response is expected. This is typically used when the\nreceiving application is not sensitive to the loss of a message. This is typically\nthe case with data that is sent using a periodic heartbeat. For example, if a\ntemperature sensor used for space comfort control in a room reports the\ntemperature will be updated on the next heartbeat.\nacknowledged, and repeated—can be used with any layer-3 address mode: broadcast,\nunicast, multicast, or Neuron ID. The exception is that broadcast acknowledged\ntransactions complete once a single acknowledgment is received—any remaining\nacknowledgements are ignored.\nThe Control Network Protocol\n60",
    "Page_61": "CNP Timers\nCNP implementations use the following timers to manage the various layer 4\nservices:\nTransaction timer\nRepeat timer\nGroup receive timer\n·Non-group receive timer\nFree-buffer wait timer\nThese timers are collectively known as the layer-4 timers, and are typically\nautomatically configured by a network management tool. For example, the\nLonMaker tool automatically calculate and configure these timers.\nThe following sections detail, for each of the four message services, how packets flow\nthrough a CNP implementation and where the timers come into play.\nUnacknowledged Service\nWhen this service is used, the only timer that is involved is the free buffer wait\ntimer. This timer determines the maximum length of time the device will wait for a\nfree buffer when sending a message. This timer can be deactivated (the device will\nwait forever) by setting the timer value to zero. If it is set to another number, n, then\nthe device will wait between 2i and 2i + 1 seconds. For example, if the configured\nnumber n is set to 2, then the device will wait for a free buffer for between 4 and 5\nseconds. If a buffer is not obtained before the timer expires, the device assumes a\nfatal error and resets.\nAcknowledged Service\nAcknowledged service also uses the free buffer wait timer, but additional timers are\nnecessary. The sending device uses a transaction timerto determine when a retry\nshould be attempted. The receiving devices use a receive transaction timerto detect\nduplicate messages.\nSending Acknowledged Messages\nThe transaction timeris used by a sending device to determine how long the device\nwaits for an acknowledgement before retrying. The value of the transaction timer\nused by the device is taken from the transmitting device's address table entry for the\ndestination address of the packet being sent. The transaction timer is individually\nconfigurable by destination address in the address table. If the device does not\nreceive an acknowledgement before the transaction timer expires, it will retry,\nsending the same packet again (along with an indication of which devices did\nacknowledge, in the case of group addressing). This retry process will continue until\nthe retry count has been exhausted or until all acknowledgements have been\nreceived. The retry count is configurable from 0 to 15 by address table entry.\nThe appropriate length for the transaction timer is dependent on the number of\nrouters and types of channels that a message must pass through between its source\nThe Control Network Protocol\n61",
    "Page_62": "and furthest destination (in terms of transit time including channel and router\n delays). The transaction timer should be just long enough so that a packet can reach\nthe furthest destination and the acknowledgement from this destination can be\nreceived before the transaction timer expires. If the transaction timer is too short,\nexcess retries will be generated; if too long, the time for a transaction to complete will\nincrease on average.\nBy adjusting the transaction timer, the time delay before messages are retried (due\nto lack of acknowledgement) can be optimized, therefore improving response time.\nTo keep the number of retries to a minimum, this timer must be set high enough to\naccommodate the round trip delay of sending a message and getting an\nacknowledgement back. On a network running at 78 kbps or 1.25 Mbps, where the\nsource and destination(s) are all on the same channel, the transaction timer can be\nset to a low value such as 64ms or 96ms. In the case where the packet has multiple\ndestinations, the path to the furthest destination must be used to calculate the timer\nvalue. A device will not try to initiate retransmission until its transaction timer\nexpires.\nThe LonMaker tool automatically calculates the transaction time defaults based upon\ntopology, bit rate, and the Neuron system clock frequency for Neuron hosted devices.\nReceiving Acknowledged Messages\nThe receive transaction timeris used by destination devices to detect duplicate\nmessages. Each device maintains a receive transaction table that stores the source\naddress and a transaction ID of all messages received within the interval defined by\nthe receive transaction timer. When a packet arrives at its final destinations, the\nreceiving devices look at the packet's source address and transaction ID. If there are\nno matching entries in the receive transaction table, a new receive transaction entry\nis created. If the receive transaction table is full and can accept no more entries, the\nincoming message is lost. If the lost message was an acknowledged message, no\nacknowledgement is returned. A receive timeris started for each entry in the table.\nThe duration of the receive timer is based upon the layer-3 address mode that the\ntransmitter used. If the transmitter used group addressing and an address table\nentry for that group exists, the group receive timervalue is taken from that entry in\nthe address table. If any other addressing mode is used, the device uses its\nnon-group receive timer value instead.\nWhen the receive timer expires, the entry in the receive transaction table is deleted,\nand any new transmission having the same transaction ID from the same source\naddress will be treated as a new transaction. Therefore, this timer must be greater\nfrom the transmitter. A good rule of thumb for setting this timer is:\nIf the receive transaction timer is too long, then it is likely that the device will run\nout of memory for receive transaction entries. If it is too short, then the device may\nmistake legitimate retries for new transactions, causing duplicate messages to\nmistakenly be passed on to the application for processing. A good rule of thumb is to\nkeep the retry count low (typically 4) and design networks with as few router hops\nfrom end-to-end as possible; this will keep the transaction timer short. As an\nexample, for a received message that originates from a device with a retry count of 4\nand a transaction timer of 200ms, use the rule-of-thumb above to arrive at ((4 + 2) *\nThe Control Network Protocol\n62",
    "Page_63": "200), or 1200ms. A shorter value could result in retries being interpreted as new\ntransactions; a longer value could result in a device's running out of receive \ntransaction buffers and losing incoming messages.\nRepeated Service\nThis service follows essentially the same message flow as acknowledged service, with\na few exceptions. In the address table of the transmitter there is a separate timer\nknown as the repeat timer. This timer specifies how frequently the message is\nrepeated when using repeated service. This time can be shorter than the transaction\ntimer, because no acknowledgement is expected (no time for the acknowledgement\nneed be allotted) when these messages are sent. Transaction IDs and duplicate\ndetection are in effect for these transactions. The initial packet is repeated as many\ntimes as is specified by the repeat count, from 1 to 15 times. This timer should be\nlong enough for the receiving device or devices to overcome any short term buffer\nshortages.\nTransportPacketFormat\nThe transport layer builds a transport packet by adding a transport header to an\nenclosed packet. The enclosed packet may be null, in which case the transport\npacket consists solely of the transport header. A transport packet has the following\nformat:\nmsb\n|Isb\nAuth\nTransport P acket\nTransactionNumber\nFormat\nEnclosed Packet\nThe Auth field is set to 1 for an authenticated message, and is set to O for messages\nthat are not authenticated.\nThe Transport Packet Format field defines the format of the packet enclosed within\nthe transport packet, and contains one of the following values:\nTransport Packet\n Transport Packet\nFormat Field\nFormat\nAcknowledged Message\n1\nRepeated Message\n2\nAcknowledgement\n4\nReminder Preamble\n5\n Reminder Message\nThe Control Network Protocol\n63",
    "Page_64": "Acknowledged (transport packet format 0) and repeated (transport packet format 1)\nenclosed packets consist of presentation packets as described in Layer 6\nPresentation Layer. The acknowledged transport packet is used for the first\ntransmission of an acknowledged message (the reminder preamble and reminder\n message are used for subsequent transmissions). The repeated transaction packet is\nused for all the transmissions of a repeated message.\nAn acknowledgement (transport packet format 2) has no enclosed packet and consists\nsolely of the transaction header.\nA reminder preamble (transport packet format 4) enclosed packet flags the first\n message of a message pair that is used for selective soliciting of acknowledgments for\nmulticast transactions. This message pair is used by a device that has transmitted a\nmulticast message, and the highest numbered group member that has not responded\nis member number 16 or higher. The second message of the pair is a retransmission\n of the original acknowledged message. The reminder preamble has the following\nformat:\nIsb\nLength\nMember List (3 to 8 bytes)\nThe Length field specifies the number of bytes in the member list, and will be a value\nbetween 3 and 8. The Member List field is a bit map of the members in the group.\nEach bit represents a member of the group where the LSB of the first byte represents\nmember O, the next bit is member 1, etc. A value of 0 indicates that the member's\nacknowledgment has not been received by the sender, a value of 1 indicates that the\nacknowledgment has been received.\nA reminder message (transport packet format 5) enclosed packet combines a\nreminder preamble with the original presentation packet and has the following\nformat:\nmsb\nlsb\nLength\nMember List (0 to 2 bytes)\nPresentation Packet\nThe Length and Member List fields have the same format as for the reminder\npreamble. A Length value of O means all members should acknowledge.\nLayer 5- Session Layer\nThe session layer adds control to the data exchanged by the lower layers. It supports\nremote actions so that a client may make a request to a remote server and receive a\nThe Control Network Protocol\n64",
    "Page_65": "response to this request. For application messages, the request is passed to the\nreceiving application which generates the response.\nThe session layer also defines an authentication protocol that enables receivers of a\nmessage to determine if the sender is authorized to send the message. This can be\nused to prevent unauthorized access to devices and their applications.\nRequest/Response\nThe request/response service is used when a message is sent to a device or group of\ndevices and individual responses are required from each receiver. The incoming\nmessage is processed by the application on the receiving device before a response is\ngenerated. The same retry and time-out options are available as with acknowledged\nservice. Responses may include data, making this service particularly suitable for\nimplementing remote procedure calls or client/server applications.\nWith one exception, the request/response service can be used with any layer-3\naddress mode: broadcast, unicast, multicast, or Neuron ID. The one exception is that\nwhen performing a broadcast request/response the application will receive only the\nfirst response; all others will be discarded by the network layer.\nThe message flow for request/response service is identical to acknowledged service,\nexcept that the application sends a response in lieu of an acknowledgement.\nNetwork management tools must take into account the extra processing time\nrequired by the application to generate the acknowledgement when calculating the\ntransaction and receive transaction timers.\nAuthentication\nWhen using authenticated messages, the receivers of an authenticated message\ndetermine if the sender is authorized to send that message. This can prevent\nunauthorized access to devices and their applications. This can be used to prevent\nunauthorized access to devices and their applications. For example, by using\nauthentication, an electronic lock device can verify that an “open\" request comes from\nthe owner, not from someone attempting to break into the system\nAuthentication is implemented by distributing 48-bit keys, one per domain, to the\ndevices at or prior to installation time. For an authenticated message to be accepted\nby the receiver, both sender and receiver must possess the same key. This key is\ndistinct from the device's Neuron ID.\nAs shown in Figure 22, when an authenticated message is sent, the receiver\nchallenges the sender to authenticate itself, using a different random number as a\nchallenge every time. The sender then authenticates by transforming the challenge,\nusing the authentication key along with the data in the original message. The\nreceiver compares the reply to the challenge with its own transformation on the\nchallenge. If the transformations match, the transaction goes forward. This is called\nan authenticated transaction. The transformation used is designed so that it is\nextremely difficult to deduce the key, even if the challenge, reply, and authentication\nalgorithm are all known. The use of authentication is configurable individually for\neach network variable connection. In addition, network management transactions\nmay be optionally authenticated.\nThe Control Network Protocol\n65",
    "Page_66": "Sander\nO Auihanleried Metusge\nRecelvar\n4-bi Random Chlenge )\nchelenge uaing\nO Chel hnge Rapty\nprtanle kary\n Tranuform chalenge\nuelrg pr wate bey anrd\nAaknowkdgment \ncompire to repty\nFigure 22  Authentication Sequence\nThe authentication protocol is always enabled on every CNP device, and every\ndomain on every device always has an authentication key. The default\nauthentication key is typically FF FF FF FF FF FF. For example, the LNS Network\nOperating System uses this value for devices that do not use authentication, but does\nnot allow this value to be used as the authentication key for a device that uses\nauthentication.\nAuthentication Control\nFor a given message, it is up to the sender of the message to initiate an authenticated\ntransaction when required. The sender does this by setting the authentication bit in\nthe message. When a receiver receives a message with the authentication bit set, it\n must respond with an authentication challenge, even if it does not require the\nmessage to be authenticated. It is up to the receiver to determine whether or not the\nmessage must be authenticated. This means that a sender may initiate an\nauthenticated transaction on any message, whether required or not. However, a\nsender should not initiate an authenticated transaction unless it is required by the\nreceiver, since authenticated transactions consume double the bandwidth of non-\nauthenticated transactions. In a group connection, there may be a mixture of\nreceivers that require authentication and receivers that do not require\nauthentication. In this case, any update sent to the group must be sent as an\nauthenticated transaction, even though all receivers do not require it.\nA receiver may choose to honor a request initiated by a failed authentication\ntransaction, and will typically do so for any messages that do not require\nauthentication. For example, if a receiver does not require network management\nmessages to be authenticated but receives a Read Memory request with the\nauthentication bit set in the message, the receiver sends an authentication challenge,\nbut ignores the authentication response and sends the results of the Read Memory\nrequest as if the authentication bit was not set.\nSession P acket Format\nThe session layer builds a session packet by adding a session header to an enclosed\npacket. The enclosed packet may be null, in which case the session packet consists\nsolely of the session header. A session packet has the following format:\nThe Control Network Protocol\n66",
    "Page_67": "msb\nIsb\nAuth\nSession Packet\nTransaction Number\nFormat\nEnclosed Packet\nThe Auth field is set to 1 for an authenticated message, and is set to O for messages\nthat are not authenticated.\nThe Session Packet Format field defines the format of the packet enclosed within the\nsession packet, and contains one of the following values:\nSession Packet\nFormat Field\nSession Packet Format\n0\nRequest\n2\nResponse\n4\nReminder Preamble\n5\nReminder Message\nRequest (session packet format 0) and response (session packet format 2) enclosed\npackets consist of presentation packets as described in Layer 4—Transport Layer.\nThe request session packet is used for the first transmission of a request message\n(the reminder preamble and reminder message are used for subsequent\ntransmissions). The response session packet is used for response messages.\nA reminder preamble (session packet format 4) session packet flags the first message \nof a message pair that is used for selective soliciting of responses for multicast\nrequests. This message pair is used by a device that has transmitted a multicast\nrequest, and the highest numbered group member that has not responded is member\nnumber 16 or higher. The second message of the pair is a retransmission of the\noriginal request. The reminder preamble has the following format:\nmsb\nIsb\nLength\nMember List (3 to 8 bytes)\nThe Length field specifies the number of bytes in the member list, and will be a value\nbetween 3 and 8. The Member List field is a bit map of the members in the group.\nEach bit represents a member of the group where the LSB of the first byte represents\nmember O, the next bit is member 1, etc. A value of 0 indicates that the member's\nresponse has not been received by the sender—a value of 1 indicates that the\nresponse has been received.\n preamble with the original presentation packet and has the following format:\nThe Control Network Protocol\n67",
    "Page_68": "msb\nIsb\nLength\nMember List (0 to 2 bytes)\nPresentation Packet\nThe Length and Member List fields have the same format as for the reminder\n preamble. A Length value of O means all members should respond.\nAuthenticated Packet Format\nTwo special packets are generated for authenticated transport packets and session\npackets. The first is the Challenge Packet which is sent by a receiver whenever a\ntransport packet or session packet is received with the authentication bit set. A\nChallenge Packet has the following format:\nmsb \n|lsb\nAddrFormat\n0\nTransaction Number\nRandom Bytes (8 bytes)\nDestination Group (0 or 1 byte)\nThe Addr Format field is the same as the Addr Format field in the network header,\ndescribed in Addressing Formats.\nThe Transaction Number field contains the same transaction number as the\nchallenged Transport Packet or Session Packet.\nThe Random Bytes field contains a challenge consisting of 8 random bytes.\nThe Destination Group field is present only if the Addr Format field specifies a group\naddress (address format 1). This field contains the same value as the Destination\nGroup field in the network header.\nWhen the transmitting node receives the challenge, it responds with a Reply Packet.\nThe Reply Packet has the following format:\nmsb\n|lsb\nAddrFormat\nTransaction Number\nChallenge Reply (8 bytes)\nDestination Group (0 or 1 byte)\nThe Addr Format, Transaction Number, and Destination Group fields are the same\nas for the Challenge Packet.\nThe Challenge Reply field contains an 8-byte value that is computed using the\n original presentation packet, the transmitter's authentication key, and the 8 random\nbytes in the challenge.\nThe Control Network Protocol\n68",
    "Page_69": "Layer 6- Presentation Layer\nThe presentation layer adds structure to the data exchanged by the lower layers by\ndefining the encoding of message data. Presentation layer services are provided by\nthe Neuron firmware for applications hosted on a Neuron core; these services are\n provided by the host or split between a host and a LoNWoRKS network interface for\napplications running on other host processors.\nMessages\n Data is exchanged between applications at layer 6 encoded as messages. Each\nmessage consists of a 1-byte message code followed by 0 to 227 bytes of data, with the\nexception of network variables that consist of 1 to 31 bytes of data. The message code\nidentifies the type of data contained within the message. Table 10 lists the message\ntypes supported by CNP, and the message codes used for each type.\nTable 10 Message Codes\nMessage Code\nMessage Code\nMessage Type\n(hex)\n(decimal)\nUser Application Message\n00-2F\n0-47\nStandard Application Message\n30-3E\n48 - 62\nForeign Frame Message\n40 - 4E\n64 - 78\nNetwork Diagnostic Message\n50-5F\n80 - 95\nNetwork Management Message\n60 -7F\n96 - 127\nNetwork Variable Message\n80-FF\n128- 255\nA message may be encoded as a network variable, application message, or foreign\nframe. Applications typically exchange data using network variables. Network\nvariables are a class of message packets with an identifier that identifies the data as\na data value that may be shared by multiple devices on a network. Interoperable\nencoding of network variables is provided with standard network variable types\n(SNVTs). A SNVT specifies a standard data encoding that determines how\napplications will interpret the data contained in a network variable. SNVTs promote\ninteroperability by ensuring that applications use a common interpretation of data\nexchanged through network variables. For example, two devices exchanging a\ntemperature network variable can use a SNVT to ensure that both devices interpret\nthe temperature data using the same units, instead of one device using Celsius and\nanother using Fahrenheit.\nApplication messages are used by application programs requiring a different data\ninterpretation model than network variables. Application messages are message\npackets with a 6-bit message code that identifies the packet to the receiving\napplication. The applications exchanging application messages must agree on the\ninterpretation of the message codes. Standard message codes are used for standard\nservices as listed in Table 11.\nThe Control Network Protocol\n69",
    "Page_70": "Table 11 Standard Application Message Codes\nMessage Code\nMessage Code\nMessage Type\n(hex)\n(decimal)\n Data Log Access Request Message\n3C\n60\nInteroperable Self-Installation Message\n3D\n61\nFile Transfer Message\n3E\n62\nForeign frames are exchanged as a simple array of bytes that can be interpreted by\nthe application in any way (for example, as a frame of a foreign protocol).\nThe message types are described in more detail in the following sections.\nMessage codes are also used for responses to request/response messages, and are\nencoded as shown in Table 12.\nTable 12 Message Codes for Responses\n Message Code\nMessage Code\nMessage Type\n(hex)\n(decimal)\n0-62\nApplication Response\n00-3E\nResponder Offline Response\n63\nForeign Frame Message\n40-4E\n64 - 78\nForeign Responder Offline\n4F\n79\nResponse\nNetwork Diagnostic Success\n30 -3F\n48 - 63\nNetwork Diagnostic Failure\n10-1F\n16 -31\nNetwork Management S uccess\n21-3F\n29 -28\nNetwork Management Failure\n00-1F\n0-31\nNetwork Variable Poll Response\n80-FF\n128-255\nNetwork Variables\nNetwork variables are CNP data values that may be shared among multiple devices.\nNetwork variables may represent a single value or a structure or union of multiple\nvalues containing 1 to 31 bytes. A device may have multiple network variables, and\neach network variable may be shared with one or more network variables on any\n device or group of devices within a network.\nUp to 31 bytes may be embedded in a network variable structure and propagated as\na single network variable. If more than 31 bytes of data are needed in a single\nmessage, application messages can be used as described in the next section. Network\nThe Control Network Protocol\n70",
    "Page_71": "variables may also be organized as arrays of network variables, where each element\nof the array may be individually connected to network variables on other devices.\nEvery network variable has a direction, type, and length. The network variable\ndirection can be either input or output, depending on whether the network variable is\nused to receive or send data. The network variable type determines the encoding and\nunits of the data.\nNetwork variables of identical type and length but opposite directions can be\nconnected to allow the devices to share information. Connections can be established\nbetween output and input network variables on different devices, or between output\nand input network variables on the same device. The latter type of connection is\ncalled a turnaround connection. Connections may be thought of as “virtual wires,\"\nreplacing the physical wires of traditional hard-wired systems.\nAn example of two devices with a connection between them is an application on a\nlighting device that has a switch-type input network variable, and a second\napplication on a dimmer-switch device that has a switch-type output network\nvariable. A network tool such as the LonMaker tool can be used to connect these two\ndevices, allowing the switch to control the lighting device, as shown in Figure 23.\nThis type of connection from a single output to a single input is called a unicast\nconnection.\nSwitch\nLight\nFigure 23 Unicast Network Variable Connection\nThe direction indicated by the triangle in Figure 23 indicates the direction of the\nnetwork variable. A single network variable may be connected to multiple network\nvariables of the same type but opposite direction. The example in Figure 24 shows\nthe same switch being used to control three lights:\nThe Control Network Protocol\n71",
    "Page_72": "Fee\nLight 1\nSwitch\nLight 3\nFigure 24 Multicast Network Variable Connection\nThe application program in a device does not need to know anything about where its\ninput network variable values come from or where its output network variable values\ngo. When the application program has a changed value for an output network\nvariable, it simply passes the new value to the CNP implementation. Rather than\nexpose the internal operation and configuration of every device to every other device\n on a network, network variables allow devices to only expose data that is required to\ninteroperate with other devices. For example, the dimmer-switch device in Figure 24\ncould be replaced with an occupancy sensor, without making any changes to the\nlighting devices.\nA connection is created through a process called binding. Binding typically takes\nplace during network design and installation. Binding may be done by a network\nmanagement tool such as the LonMaker too, or may be done by the device application\nitself through a process called self-installation. When binding network variables, the\n CNP implementation is configured to know the logical address of the other device or\ngroup of devices in the network expecting that network variable's values. It\nassembles and sends the appropriate packets to these devices. Similarly, when the\nCNP implementation receives an updated value for an input network variable\nrequired by its application program, it passes the data to the application program.\nThe binding process thus creates the logical connections between an output network\nvariable in one device and an input network variable in another device or group of\ndevices.\nNetwork variables provide a data oriented application protocol. Application data\nitems such as temperatures, pressures, states, text strings, and other data items are\nexchanged between devices in standard engineering and other predefined units.\n Commands are encapsulated within the application programs of the receiver devices \nrather than being sent over the network. In this way, the same engineering value\ncan be sent to multiple devices which each have a different application program, and\npotentially different commands, for that data item.\nThe network variable concept greatly simplifies the programming of complex\ndistributed applications. Network variables provide a very flexible view of\ndistributed data to be operated on by the devices in a system. The programmer need\nThe Control Network Protocol\n72",
    "Page_73": "not deal with message buffers, network addressing, request/response/retry\n processing, and other low-level details that must typically be managed for other\nprotocols.\nNetwork Variable Selection\nConnections consist of addressing information at CNP layers 3 and 6. The layer-3\naddress delivers a network variable update to the correct set of devices; the layer-6\naddress selects the correct network variable on those devices.\nTo support network variable selection at layer 6, each network variable on a device\nhas a unique network variable index for that device. Network variable indexes are\nassigned sequentially for each network variable on the device, starting with index 0.\nFor example, a device with a switch output and a switch feedback input may use\nindex O for the output and index 1 for the input.\nThe layer-6 address for a network variable is called the network variable selector. A\nnetwork variable selector is an identifier that is used to associate a network variable\nupdate message with a network variable within the receiving application. Every\nnetwork variable update message includes a network variable selector, and every\nCNP device maintains one or two tables that are used to associate a network variable\nselector with a network variable index. The first table implemented by all CNP\ndevices is the network variable configuration table. The second table that may\noptionally be implemented by a CNP device is the network variable alias table.\nWhen sending a network variable update, the layer-6 implementation uses these\ntables to translate the network variable index on the sending device to a network\nvariable selector. When receiving a network variable update, the layer-6\nimplementation uses these tables to translate the network variable selector to a\nnetwork variable index on the receiving device.\nBecause network variable updates are first filtered by the network-layer address,\nnetwork variable selectors may be reused within a domain. Network variable\nselectors must be unique for all network variable update and poll request messages\nreceived by a device, but may be reused within two connections that have no common\ndevices.\nThe network variable selector is a 14-bit identifier with a value between O and 3FFF\nhex. Selector values 3000 to 3FFF hex are reserved for unbound network variables,\nwith the selector value equal to 3FFF hex minus the network variable index. This\nconvention allows unbound network variables to be polled, as long as the polling\ndevice has the network variable index of the network variables to be polled. Selector\nvalues 0 to 2FFF hex are available for bound network variables. This provides a\ntotal of 12,288 different network variable selectors for bound network variables, some\nof which may be reused as described in the previous paragraph.\nNetwork Variable Aliases\nEach network variable on a device may have multiple layer-6 addresses, that is, each\nnetwork variable may have multiple selectors. Each selector for a network variable\ncreates a virtual network variable. The primary selector defines the primary\nnetwork variable. The additional selectors, if any, create alias network variables,\nsimply called aliases. A primary network variable and all of its aliases share a\nThe Control Network Protocol\n73",
    "Page_74": "common network variable value. When the CNP implementation sends a network\nvariable update, it sends the updated value to the primary network variable and all\nof its aliases. When the CNP implementation receives a network variable update, it\ncompares the selector contained in the update to the selectors defined for all primary\nnetwork variables and all aliases, until a match is found or until all primary network\nvariables and aliases are searched, whichever comes first.\nNetwork Variable Configuration and Alias Tables\nThe network variable configuration and alias tables map network variable selectors\nto network variable indexes and vice versa. Each entry in the two tables contains a\ninformation, a priority flag, and an authentication flag for the network variable. The\nnetwork variable configuration table has an entry for each network variable\nimplemented by the device. The network variable configuration table entries are\nindexed by the network variable index. The network variable alias table has an\nentry for each alias, and associates each alias with a primary network variable if the\nalias is active. The alias for a network variable shares the network variable value\nwith the associated primary network variable.\nNetworkVariable Limits\nCNP supports up to 4096 primary network variables and 8192 network variable\naliases per device, but the maximum number may be further limited by specific CNP\nimplementations. The typical limit for a Neuron hosted device is 254 primary\nnetwork variables and 127 aliases. The maximum number of network variables and\naliases per device may also be limited by the network management tool used to bind\nthe device; different tools will have different capacities depending on their memory\nand database size.\nThe number of network variables that can be implemented on a device does not limit\nthe number of network variables that can be accessed by the device. A single input\nnetwork variable can receive data of the same type from an unlimited number of\ndevices—potentially from every device within the domain. The receiving application\ncan differentiate network variables from different device by examining the source\naddress of the network variable. For example, an alarm monitoring system may\nhave 1oo0 alarm output network variables bound to a single alarm input network\nvariable on a monitoring device. This configuration only requires a single input on\nthe monitoring device, yet the application on the monitoring device can still\ndetermine the source of any alarm by reading the source address field of the message.\nA single output network variable can be used to send data of the same type to an\nunlimited number of devices—potentially to every device within the domain.\nNetwork Variable Types\nNetwork variables provide a mechanism for exchanging data values between devices,\nbut the network variable packets do not specify the encoding of the data. For\nexample, two devices exchanging network variable updates representing current\ntemperature could have different encoding for the data. If the sending device uses\nCelsius values with a fixed point representation providing 0.1 degree resolution, and\nthe receiving device expects Fahrenheit integer values, the two devices would be\nincompatible. One solution to this problem is to add a third device in between the\nThe Control Network Protocol\n74",
    "Page_75": "two incompatible devices to perform the temperature conversion. This approach\nworks, but unnecessarily complicates system integration.\nNetwork variable types are used to ensure compatible interpretation of data. A\nstandard set of network variable types defines standard units, ranges, and resolution\nfor most common units of measure, and also defines many standard structures for\ncommon aggregate data. These standard types are called standard network variable\ntypes, or SNVTs (pronounced snivets). The list of SNVTs includes over 1o0 types and\ncovers a wide range of applications. The complete list is available at\ntypes.lonmark.org. New SNVT definitions are added when new types are required\nfor applications created by multiple vendors. If an application requires a network\nvariable type that is not a SNVT, device-manufacturers can define custom network\nvariable types. These are called user network variable types (UNVTs pronounced\nyou-nivits).\n        e  n e    \ndescribes the scalar data types, and Table 14 describes the aggregate data types.\nTable 13 Scalar Data Types\nData Type\nDescription\nBitfield\nA signed or unsigned bitfield, 1-8 bits wide. Only\navailable for fields within a structure or union.\nDouble Float\nAn ANSI/IEEE 754 standard 64-bit\ndouble-precision floating point value with 1 sign bit,\n11 exponent bits, and 52 mantissa bits, for a total\nof 64 bits. The maximum range is approximately\n-1E308 to +1E308 units.\nE numerated\nA signed 8-bit enumerated value.\nFloat\nAn ANSI/IEEE 754 standard 32-bit floating point\nvalue with 1 sign bit, 8 exponent bits, and 23\nmantissa bits, for a total of 32 bits. The maximum\nrange is approximately -1E38 to +1E38 units.\nReference\nA reference to a network variable type. Uses the\ntype definition of the referenced network variable\ntype. If you are creating a structure or union, an\nindividual field can reference a network variable\ntype. If the referenced network variable type\nchanges in some way, the referencing type or field\nwill automatically change as well.\nSigned Character\nAn 8-bit signed character value.\nSigned Long\nA 16-bit signed integer value. Maximum unscaled\nrange of -32,768 - 32,767.\nSigned Quad\nA 32-bit signed integer value.\nSigned Short\nAn 8-bit signed integer value. Maximum unscaled\nrange of -128 - 127\nUnsigned Character\nAn 8-bit unsigned character.\nUnsigned Long\nA 16-bit unsigned integer value.\n. Maximum\nunscaled range of 0 - 65,535.\nThe Control Network Protocol\n75",
    "Page_76": "Data Type\nDescription\nUnsigned Quad\nA 32-bit unsigned value.\nUnsigned Short\nAn 8-bit unsigned integer value. Maximum\nunscaled range of 0 - 255.\nTable 14 Aggregate Data Types\nData Type\nDescription\nStructure\nA structure containing multiple fields. Each field\n may be any of the scalar types described in Table\n13.\nUnion\nA union containing multiple fields. Each field may\nbe a structure or any of the scalar types described\nin Table 13.\nScalar data types and fields specify scaling factors that can be used to modify the\nrange of the type. The scaling factors are defined by three values called A, B, and C.\nThese values are used to calculate a scaled value as follows:\nScaledValue= A * 10B * (UnscaledValue + C)\nFor example, the SNVT_lev_percent type is defined to represent a one-byte\npercentage value. The scaling factors are defined as A=5, B=-2, and C=0, resulting in\nthe following scaling formula:\nScaledValue = 5 * 10-3 * (UnscaledValue + 0)\nUsing this formula, an unscaled value of 200 results in a scaled value of 100. A value\nof 1 results in 0.5, providing an 0.5 percent resolution.\nScalar data types and fields define a units string that describes the data contained\nwithin the network variable or field. This string may be specified in multiple\nlanguages to allow localization of displayed values. For example, the\n English-language unit string for the SNVT_lev_percent network variable type is “%\nof full scale.\"\nUnits of measures are typically specified in Systeme Internationale (SI) units. For\nexample, temperature is always represented in Celcius. A standard mechanism is\nprovided to scale measurement values. This allows measurement values to be\ndisplayed in alternative systems. For example, temperature can be displayed in\nFahrenheit using an appropriate format.\nScalar data types and fields define minimum and maximum values for the network\nvariable type. These values restrict the values that may be assigned to the network\nvariable or field. Scalar data types may also define an invalid value. An invalid\nvalue indicates that the value of the network variable is unknown. For example, a\ntemperature sensor network variable output that reports an invalid value indicates\nthat the current temperature is not available.\nNetwork Variable Self-identification and Self-documentation\nSNVTs are self identifying, meaning that a network tool can extract the type\ninformation for all network variables on a device that are declared as SNVTs.\nThe Control Network Protocol\n76",
    "Page_77": "Network variables may also have a self documentation string that can be used to\nprovide more information to a network tool. For example, a device that contains two\ntemperature sensors, one for input temperature and one for output temperature, has\ntwo network variable outputs. These outputs are both declared using SNvT_temp,\nautomatically identifying the values as encoded Celsius values with a resolution of\n0.1°C. Each of the network variables has a self documentation string defined by the\ndevice application. The string for the first device is: “Input Temperature Sensor\",\nand the string for the second is “Output Temperature Sensor.\"\nPresentation P acket\nThe presentation packet defines the physical encoding of the presentation layer data.\nThe first byte of the presentation packet is the message code as described in Table 10\nand Table 12. For network variables, the message code specifies the upper 6 bits of\nthe network variable selector.\nNetwork variable updates and polls are encoded as CNP messages containing the\nnetwork variable selector and the new network variable value. The following figure\nillustrates the format of network variable messages. The Selector Hi field contains \nthe top 6 bits of the selector, and the Selector Lo field contains the lower 8 bits of the\nselector. The Dir field is O for input network variable updates and 1 for output\nnetwork variables. While only input network variables can receive a new value\nthrough layer-6 addressing, both input and output network variables can be read\nremotely using layer-6 addressing through a network variable poll request message.\nmsb\nIsb\n1\nDir\nSelector Hi\nSelector Lo\nNetwork Variable Data (1 to 31 bytes)\nMulti-byte network variables are sent with the most significant byte first. Arrays\nare sent with the lowest numbered element first. Structures are sent with the first\nfield at the beginning.\nThe presentation packet for an application message has the following format:\nmsb\n|lsb\n0\nApplication Message Code\nApplication Message Data (0 to 249 bytes)\nThe presentation packet for a foreign frame message has the following format:\nmsb\n|Isb\n0\n1\n0\n0\nForeign Message Code\nForeign Frame Data (0 to 249 bytes)\nThe Control Network Protocol\n77",
    "Page_78": "Explicit NetworkVariablePolls\n In certain applications, it is desirable for an application to explicitly create a message\nthat has the same structure as a network variable request message. By doing this,\nthe polling application can bypass the network variable configuration and address\ntables and explicitly control the destination address of the network variable request.\nFor example, a device application can poll network variables on more than 15\n different destination devices (single device or groups) by using explicit addressing to\novercome the limit of 15 address table entries on a Neuron hosted device. It can use\na single input network variable to receive an unlimited number of responses to polls\nof any given data type.\nFigure 25 illustrates the message structure of a network variable request message\nused to poll a network variable. The first byte is the message code that includes the\nSelector Hi field containing the most significant six bits of the network variable\nselector. The most significant bit of the message code is set, indicating a network\nvariable message, and the second most significant bit is set, indicating that the poll is\naddressed to an output network variable. The first data byte of the request message\ncontains the Selector Lo field with the least significant eight bits of the network\nvariable selector; there is no additional data in the request. After the polling device\nsends the explicit network variable request message, the destination devices will\nsend their network variable values as network variable response messages. A\nresponse message contains the same code as the request message, except that the\nsecond most significant bit is clear, indicating that the response is addressed to an\ninput network variable. The first data byte of the response contains the least\nsignificant eight bits of the network variable selector, and this is followed by the\nrequested data value of the network variable. If the poll is received by a destination\n device that has no matching network variable, or the destination device is offline,\nthen the response contains the selector, but no data is present.\nmsb |\n[ Isb\n1\n1\nSelector Hi\nSelector Lo\nFigure 25Network Variable Request Message Structure\nA response message is processed by the network processor on the polling device,\nbefore the response is passed to the application processor. A Neuron C application\nprogram cannot receive the response using explicit messaging syntax. If the polling\ndevice has an input network variable with the same selector and the same size as the\npolled network variable, then this network variable will be updated by the response\nto the poll.\nInstead of using an explicit network variable request message, an alternative method\nof reading the value of a network variable with an explicitly addressed message is\nwith the Network Variable Fetch network management message. The Network\nVariable Fetch message addresses the network variable by its network variable\nindex, while the network variable poll message addresses a network variable (or one\nof its aliases) by its selector.\nWhen a network variable poll is addressed using group (multicast) addressing with\nacknowledged service, all members of the group acknowledge the poll request\nThe Control Network Protocol\n78",
    "Page_79": "message. Those members of the group that have output network variables with a\nmatching selector will respond with a message containing the value of the variable.\nThese responses will generate NV update events on the polling device. Those\nmembers of the group that have an input network variable with a matching selector,\n or no network variable with a matching selector, or are offline, will generate a\nparticipation of the application processor in the polled device, and occurs at the end\nof the currently executing critical section for a Neuron C application. This should be\ntaken into account when designing the application code for a device whose network\nvariables may be polled, and when configuring the transaction timer for the poll\nmessage. If all the responses are successfully received by the polling node, an NV\nupdate succeeds event is generated. If one or more responses are not received after\nthe configured number of retries, an NV update fails event is generated.\nLayer 7- Application Layer\nThe application layer defines a rich set of standard network services that use data\nexchanged by the lower layers. These include network configuration and diagnostic\n services as well as standard application-layer services. The application layer services\nensure that devices created by different developers or manufacturers can\ninteroperate with each other, and can be installed and configured using standard\nnetwork tools. The network configuration and network diagnostic services are\ndefined by the CNP standard. The following list summarizes the standard\napplication-layer services. The remaining standard application-layer services are\ndefined by guidelines and functional profiles published by LoNMARK International, a\nglobal membership organization created to promote and advance the business of\nefficient and effective integration of open, multi-vendor control systems utilizing\nISO/IEC 14908-1 and related standards. A complete set of guidelines and functional\n profiles is available at www.lonmark.org.\n Network configuration—provides a standard set of commands for configuring the\nnetwork attributes of a device. Network attributes include the network address\nand binding information for the device's network variables.\n Network diagnostics—provides a standard set of commands that can be used by\n network tools to diagnose network problems.\n File transfer supports transfer of blocks of data among devices and network\ntools. LoNWoRKs FTP transfers large amounts of data (with a theoretical\nmaximum of 2 GB) in smaller packets, taking care of resending individual\npackets where necessary, and handling out-of-order arrivals as needed. The\nlargest practical amount of data that can be transferred in a single CNP packet is\n228 bytes, but LoNWoRKs FTP transfers data using a stream of 32-byte packets.\nThe size of each packet in the stream is fixed at 32 bytes for interoperability, low\ndevice cost, and optimal channel utilization.\nApplication configuration—provides a standard interface to configure the\nbehavior of a device. The interface is based on configurable data values called\nconfigurationproperties.\nThe Control Network Protocol\n79",
    "Page_80": "Application specification—-provides a standard set of interfaces for a device to\ndocument the tasks that it performs. Each task is exposed as a functional block\nthat is defined as a set of network variables and configuration properties\ncontained within a functional block.\nApplication diagnosticsprovides a standard interface to test functional blocks\nand devices.\n· Application management—provides a standard interface to enable, disable, and\n override functional blocks on a device.\n·Alarming—provides a standard interface for a device to report alarm conditions.\n Data Loggingprovides a standard interface for a device to collect data into data\nlogs that can be transferred to a remote server using a standard interface.\nScheduling provides a standard interface for scheduling events based on time of\nday, day of week, and date.\nTime and date managementprovides a interface for synchronizing the\ntime-of-day and date for devices within a network.\nApplication Configuration\nA configuration property (CP) is a data item that, like a network variable, is part of\nthe device interface for a device. Configuration properties characterize the behavior\nof a device in the system. Network tools manage this attribute and keep a copy of its\nvalue in a database to support maintenance operations. If a device fails and needs to\nbe replaced, the configuration property data stored in the database is downloaded\ninto the replacement device to restore the behavior of the replaced device in the\nsystem.\nConfiguration properties facilitate interoperable installation and configuration tools\nby providing a well-defined and standardized interface for configuration data. Each\nconfiguration property type is defined in a resource file that specifies the data\nencoding, scaling, units, default value, range, and behavior for configuration\nproperties based on the type. A rich variety of standard configuration property types\n(SCPTs pronounced skip-its) are defined. SCPTs provide standard type definitions\nfor commonly used configuration properties such as dead-bands, hysteresis\nthresholds, and message heartbeat rates. You can also create your own user\nconfiguration property types (UCPTs pronounced you-keep-its) that are defined in\nresource files that you create with the NodeBuilder Resource Editor.\nApplication S pecification\nCNP application provides a standard set of interfaces for a device to document the\ntasks that it performs. Each task is exposed as a functional block that is defined as a\nset of network variables and configuration properties contained within a functional\nblock. The device interface, also called the XIF, may be documented by the device\nitself, or by a separate file called the device interface file, or XIF file. The device\ninterface is uniquely identified by an identifier called the program ID.\nThe Control Network Protocol\n80",
    "Page_81": "Functional Blocks and Functional Profiles\nA CNP device application is divided into one or more functional blocks. A functional\nblock is a portion of a device's application that performs a task by receiving\nconfiguration and operational data inputs, processing the data, and sending\noperational data outputs. A functional block may receive inputs from the network,\nhardware attached to the device, or from other functional blocks on a device. A\nfunctional block may send outputs to the network, to hardware attached to the\ndevice, or to other functional blocks on the device.\nThe device application implements a functional block for each function on the device\nto which other devices should communicate, or that requires configuration for\n particular application behavior. Each functional block is defined by a functional\nprofile. A functional profile is a template for functional block, and a functional block\nis an implementation of a functional profile.\nThe network inputs and outputs of a functional block, if any, are provided by network\nvariables and configuration properties. The network variables provide the\noperational data inputs and outputs for the functional block. The configuration\nproperties configure the behavior of the functional block.\nFor example, a keypad could implement a functional block based on the\nSFPTisiKeypad ISI Keypad profile, combining a SNVT_switch_2 typed network\nvariable that represents the current keypad state with configuration properties that\nspecify the state change for each key on the keypad, and hold the name for the\nkeypad. This logical unit—the functional block—can be disabled, enabled, tested,\nand managed by a network integrator.\nEach functional profile defines mandatory and optional network variables and\n mandatory and optional configuration properties. A functional block must\nimplement all the mandatory network variables and configuration properties defined\nby the functional profile, and may implement any of the optional network variables\nand configuration properties defined by the functional profile\nFunctional profiles are defined in resource files. You can use standard functional\nprofiles or you can define your own functional profiles in your own resource files\nusing the NodeBuilder Resource Editor. A functional profile defined in a resource file\nis also called a functional profile template (FPT).\nEach CNP device may include self-identification (SI) data and self-documentation\n(SD) data that identifies its device interface to network tools that are used to install\nthe device. Including selfidentification and self-documentation data with a device\n makes it easier to install, as it allows easy, plug-and-play style, integration in\nmulti-vendor networks. While self-identification and self-documentation simplify\ninstallation, these methods do not expose any of the algorithms used within the\napplication.\nProgram ID\nThe program ID is a 64-bit (16-hex-digit) identifier that uniquely identifies the\napplication contained within a device. A program ID is typically presented as eight\npairs of hexadecimal encoded digits, separated by colons. When formatted as a\nstandard program ID, the 16 hex digits are organized as 6 fields that identify the\nThe Control Network Protocol\n81",
    "Page_82": "manufacturer, classification, usage, channel type, and model number of the device.\nEvery standard program ID uses the following format:\nFM:MM:MM:CC:CC:UU:TT:NN\nThe fields are described in the following table.\nTable 15 Program ID Fields\nSegment\nField\nDescription\nF\nFormat\nA 4-bit program ID format identifier. Set to 8 for LoNMARK certified\ninteroperable devices, or to 9 for non-certified application devices. Values\nM:MM:MM\nManufacturer\nA 20-bit identifier for the device manufacturer. A manufacturer ID listing is\navailable at www.lonmark.org/spid.\n1.Manufacturers that do not have anID can\nManufacturers can get more information on joining LonMark International at\nwww.lonmark.org.\nCC:CC\nDevice Class\nA 16-bit identifier for the primary function of the device. The primary function\nof the device is determined by the primary functional profile implemented by\nthe device. The device class is equal to the functional profile number for the\nfunctional profile of the primary functional block of the device if the profile is a\nstandard profile and the standard profile is not one of the standard profiles\nbetween 0 and 6. For all other devices, the identifier is selected from one of\nthe standard device classes at www.lonmark.org/spid\nUU\nUsage\nAn 8-bit identifier for the intended usage of the device. The most significant\nbit is set if the device interface is changeable (due to network variables with\nsignificant bit is set if the remainder of the usage bits are specified by the\nfunctional profile of the primary functional block of the device. If the second\nmost significant bit is not set, the usage field is set to one of the standard\nusage values at www.lonmark.org/spid\nChannel Type\nTT\ntransceiver. The channel type values are listed at www.lonmark.org/spid\nMM\nModel Number\nAn 8-bit identifier that is used to make the program ID unique for device\ninterfaces that share the same manufacturer, device class, usage, and\nchannel type. This model number does not have to be same as the actual\ndevice model number— it just has to be unique from the model number of\nother device applications that share the same manufacturer, device class,\nusage, and channel type.\nThe Control Network Protocol\n82",
    "Page_83": "The Control Network Protocol\n83",
    "Page_84": "Appendix A.\nLayer 1 and 2 Advanced Topics\nThis appendix describes details of layers 1 and 2 of the\nISO/IEC 14908-1 Control Network Protocol (CNP) which\nare generally of interest to transceiver designers. If you\nare developing with or integrating one of the standard\ntransceivers described in Chapter 3, the options described\nin this appendix have already been addressed by the\nstandard transceiver design.\nLayer 1 and 2 Advanced Topics\n84",
    "Page_85": "Layer 1 Neuron Communications Interface\nThe Neuron core supports CNP media independence by using a flexible 5-pin\ncommunications port. This port can be configured in one of three modes to support a\nvariety of physical layer transceivers. They are single-ended, differential, and\nspecial-purpose modes. For special purpose mode, the Neuron core passes complete\ndata frames to the transceiver which is responsible for data encoding. For\nsingle-ended and differential modes, the Neuron core manages all data encoding and\nuses the transceiver only for the physical layer interface. Table 16 summarizes the\npin assignments for each mode.\nTable 16 Network Communication Port Pins\nPin\nSingle-E nded\nDifferential\nSpecial-Purpose Mode\nMode\nMode\nCPO\nData input\n+ Data input\nRx input\nCP1\nData output\n Data input\nTx output\nCP2\nTransmit Enable output\n+ Data output\nBit clock output\nCP3\n~Sleep (~Power-down)\n Data output\n~Sleep output or Wake-up\noutput\ninput\nCP4\n~Collision Detect input\n~Collision Detect\nFrame clock output\ninput\nSingle-ended and differential modes use Differential Manchester encoding which is a\nwidely used and reliable format for transmitting data over various media. In this\nencoding method, there is a minimum of one transition per bit time at the beginning\nof the bit time. If there is a second transition within the bit time, it occurs in the\nmiddle of the bit. By convention, a single transition per bit time is a “1\" and two\nevenly spaced transitions per bit time is a “0.\" Figure 26 shows the encoding of a\nsample bit stream.\n800ns @ 1.25Mbps\nFigure 26 Differential Manchester E ncoding\n Differential Manchester encoding has the benefits of zero DC offset, polarity\ninsensitivity, and simple bit synchronization between the transmitter and one or\nLayer 1 and 2 Advanced Topics\n85",
    "Page_86": "more receivers. Polarity insensitivity simplifies installation of the communications\nchannel because reversal of polarity in the communication link will not affect data\nreception.\nSingle-Ended Mode\nThe single-ended mode is most commonly used with external active transceivers\ninterfacing to media such as free topology twisted pair, radio frequency (RF) carrier,\ninfrared, fiber optic, and coaxial cable.\nFigure 27 shows the communications port configuration for the single-ended mode of\noperation. Data communication occurs via the single-ended (with respect to Vss)\ninput and output buffers on pins CPO and CP1. Single-ended mode contains an\nactive low sleep output (CP3) which can be used by the transceiver to power down\n active circuitry when the Neuron core goes to sleep.\n Differential\nNRZData\nManchester\nCPO\nData Input\n Decoder\nDifferential\nData Output\nNRZData\nManchester\nCP1\nEncoder\nTransmit Enable\nTransmitEnable\nCP2\nandano\n~Sleep (~Power-down)\n~Sleep\nCP3\nOutput\nCP4\n~Collison Detect\nInput\nCollisionDetectEnable\nFigure 27 Network Communication Port Configuration in Single-ended Mode\nIn single-ended mode, the communications port encodes transmitted data and\n decodes received data using differential Manchester coding (also known as bi-phase\n space coding). This scheme provides a transition at the beginning of every bit period\nfor the purpose of synchronizing the receiver clock, referred to as the clock transition.\nThe value of a bit is indicated by the presence or absence of a second transition (the\ndata transition) halfway between clock transitions. A mid-cell transition indicates a\nzero. Lack of a mid-cell transition indicates a one.\nFigure 28 shows a typical packet where T is the bit period, equal to 1/(bit rate).\nClock transitions occur at the beginning of a bit period, and, therefore, the last valid\n bit in the packet does not have a trailing clock edge.\nData\nTransmit\nEnable\nFigure 28 Single-ended Mode Data Format\n Before beginning to transmit a data frame, the transmitting Neuron core initializes\nthe output data pin(s) to start low. In single-ended mode, it then asserts Transmit\nEnable (CP2); this ensures that the first transition in the packet is from low to high.\nThis first transition occurs within 1 bit time of asserting Transmit Enable, and\nLayer 1 and 2 Advanced Topics\n86",
    "Page_87": "marks the beginning of the packet. Transmit Enable (CP2) and Data Output (CP1)\nare actively driven at all times in single-ended mode.\nReceiving Neuron cores use two windows for each bit period, T. The first window is\nset at T/2. If a transition is detected in the first window, a zero is being received.\nThe second window is at T. If no transition occurred in the first window, but a\ntransition occurs in the second window, a one is being received. The second \ntransition also sets up the next two windows (T/2 and T). If no transition occurs in\nthe first two windows, a Manchester code violation is detected and the packet is\nassumed to have ended. Table 17 shows the width of this window as a function of the\nratio of the Neuron input clock (MHz) and the channel bit rate (Mbps) selected. If a\ntransition falls outside of either window, it is not detected and the packet will contain\nerrors. The receiving Neuron core detects these errors and reports a bad packet.\nTiming instability of the transitions, known as jitter, may be caused by changes in\nthe communications medium, or instability in the transmitting or receiving devices'\ninput clocks. The jitter tolerance windows are expressed as fractions of the bit\nperiod, T, in Table 17. The MAC clock is 10MHz for a 5000 Series chip running at a\n10MHz or greater system clock, is 5Mhz for a 5000 Series chip running at a 5MHz\nsystem clock, and is one half the input clock for a 3100 Series chip.\nTable 17 ReceiverJ itter Tolerance and Line-code Violation Windows\nMAC Clock/\nLine-Code\nChannel Bit\nNextData Edge\nNextClockEdge\nViolation to\nRate\nReceive\nMin\nNominal\nMax\nMin\nNominal\nMax\nMin\n4:1\n0.375T\n0.500T\n0.622T\n0.875T\n1.000T\n1.122T\n1.62T\n8:1\n0.313T\n0.500T\n0.685T\n0.813T\n1.000T\n1.185T\n1.46T\n16:1\n0.345T\n0.500T\n0.717T\n0.845T\n1.000T\n1.155T\n1.46T\n32:1\n0.330T\n0.500T\n0.702T\n0.830T\n1.000T\n1.170T\n1.46T\n64:1\n0.323T\n0.500T\n0.695T\n0.823T\n1.000T\n1.177T\n1.46T\n128:1\n0.318T\n0.500T\n0.690T\n0.818T\n1.000T\n1.182T\n1.46T\n256:1\n0.315T\n0.500T\n0.687T\n0.815T\n1.000T\n1.185T\n1.46T\n512:1\n0.315T\n0.500T\n0.687T\n0.815T\n1.000T\n1.185T\n1.46T\nFor the receiver to reliably terminate reception of a packet, the received line-code\nviolation period must have no transitions until the Neuron core detects the end of the\npacket. The receiving Neuron core terminates a packet if no clock transitions are\ndetected after the last bit. Table 17 shows the minimum duration from the last clock\nedge to where the Neuron core is guaranteed to recognize the line-code violation.\nData transitions are allowed in this period (and must fall within the data window).\nDifferential Mode\n In differential mode, the Neuron core's built-in transceiver is able to differentially\ndrive and sense a twisted-pair transmission line with external passive components.\nLayer 1 and 2 Advanced Topics\n87",
    "Page_88": "Differential mode is similar in most respects to single-ended mode; the key difference\nis that the driver/receiver circuitry is configured for differential line transmission.\nData output pins CP2 and CP3 are driven to opposite states during transmission and\nput in a high-impedance (undriven) state when not transmitting. The differential\nreceiver circuitry on pins CP0 and CP1 has selectable hysteresis with eight selectable\nvoltage levels followed by a selectable low-pass filter with four selectable values of\ntransient pulse (noise) suppression. The selectable hysteresis and filter permit\noptimizing receiver performance to line conditions. See Table 18 and Table 19 for\nspecific values.\n Differential\nCPO\n+ Data Input\nNRZData\nManchester\n Filter \nDecoder\nCP1\n- Data Input\n Differential \nCP2\n+ Data Output\nNRZData\nManchester\nCP3\n- Data Output\nEncoder\nTransmit Enable\n(Tri-state control)\n~Collison Detect\nCP4\nInput\nCollision Detect Enable\nFigure 29 Network Communication Port Configuration in Differential Mode\nFigure 29 shows a typical packet waveform in differential mode. The packet format\nis identical to that in single-ended mode described earlier. The starting level for the\ndata output is the inverse of the last received level to ensure that the first transition\noccurs on the network as quickly as possible. The coding, jitter tolerance, and\nminimum line-code violation length to receive apply identically to single-ended mode.\nHtttlolllattal d\n+Data\n-Data\nFigure 30Differential Mode Data Format\nLayer 1 and 2 Advanced Topics\n88",
    "Page_89": "Table 18 Hysteresis Values Expressed as Differential Peak-to-peak Voltages in Terms of VDD\nHysteresis (H)\nMin\nTyp\nMax\nUnit\n0.019VDD\n0.027VDD\n0.035VDD\nV\n1\n0.040VDD\n0.054VDD\n0.068VDD\nV\n2\n0.061VDD\n0.081VDD\n0.101VDD\nV\n3\n0.081VDD\n0.108VDD\n0.135VDD\nV\n4\n0.101VDD\n0.135VDD\n0.169VDD\nV\n5\n0.121VDD\n0.162VDD\n0.203VDD\nV\n6\n0.142VDD\n0.189VDD\n0.236VDD\nV\n0.162VDD\n0.216VDD\n0.270V DD\nV\nTable 19 Post-hysteresis Filter Values Expressed as Transient Pulse Suppression Times\nFilter (F)\nMin\nTyp\nMax\nUnit\n0\n2\n6\n9\nns\n1\n90\n270\n580\nns\n2\n200\n535\n960\nns\n3\n410\n1070\n1920\nns\nSpecial-Purpose Mode\nIn special situations such as power line transceivers, it is desirable for the Neuron\ncore to provide the packet data in an unencoded format and without a preamble. In\nthis case, an intelligent transmitter accepts the unencoded data and does its own\nformatting and preamble insertion. The intelligent receiver detects and strips off the\npreamble and formatting and returns the decoded data to the Neuron core.\nSuch an intelligent transceiver contains its own input and output data buffers,\nintelligent control functions, and provides handshaking signals to properly pass the\n data back and forth between the Neuron core and the transceiver.\n In addition, there are many features that can be defined by and incorporated into a\nspecial purpose transceiver, for example:\n Ability to configure various parameters of the transceiver from the Neuron core;\n Ability to report on various parameters of the transceiver to the Neuron core;\nMultiple channel operation;\n Multiple bit rate operation;\nUse of forward error correction; and\nLayer 1 and 2 Advanced Topics\n89",
    "Page_90": "Media specific modulation techniques requiring special message headers and\nframing.\nWhile the special purpose mode offers custom features, most transceivers use the\nsingle-ended mode for most types of media, from coaxial cable to RF to fiber optic,\nbecause it simplifies transceiver implementation and offers Differential Manchester\nencoding, which takes care of clock recovery.\nLayer 2 Advanced Topics\nThis section describes the following layer-2 topics that are typically only of interest to\ntransceiver designers:\nInterpacket gap\nCollision detection\nCollision resolution\nOscillator accuracy\n Preample length\nInterpacket Gap\nChannel bandwidth is consumed by a series of packet cycles interspersed with idle\ntime. A packet cycle consists of the packet itself followed by the interpacket gap.\nPacket cycles vary in length due to the randomizing nature of the media access\nalgorithm as well as varying protocol overhead and application data size. This\naverage packet cycle duration determines the rate at which the media access\nalgorithm decreases its assumed backlog of offered traffic during network idle\nconditions.\nThe interpacket gap is a variable amount of time following each packet. The\ninterpacket gap ends, and idle time begins, when the MAC sublayers in all devices\nand routers on the channel reach the idle state (have no packet to send or receive).\nThe interpacket gap includes the beta 1 time and beta 2 slots. The beta 1 time is the\nfixed component in the idle period after a packet has been sent. The beta 2 slots are\nused for media access control. Figure 31 shows the contents of the interpacket gap.\nInterpacket Gap\nBeta 1 Time\nBeta 2 Slots\nPost-\nInterpacket\npacket\nPadding\nhandling\nNetwork Idle Wait \nPre-packet handling\nFigure 31  Interpacket Gap\nThe beta 1 time is a function of the following:\n Oscillators: Oscillator frequencies and accuracies on the various network\ndevices.\nLayer 1 and 2 Advanced Topics\n90",
    "Page_91": "Post-packet handling. Following the successful transmission or reception of a\npacket, if the protocol processor is a Neuron core, the Neuron MAC processor\nperforms error checks and handshakes with the Neuron network processor. The\nnumber of CPU minor cycles (200ns with a 10MHz input clock) varies as a\nfunction of the mode and direction as follows (these times are for Neuron\nfirmware versions 3 and 4 running on Neuron 3120 and 3150 Chips):\nTable 20 Neuron Core Post-Packet Processing Time\nDifferential and\nSpecial Purpose\nDirection\nSingle-Ended Mode\nMode\nTransmitter\n313 cycles\n307 cycles\nReceiver\n295 cycles\n285 cycles\nInterpacket gap padding. This padding allows the MAC sublayer in each device\nto meet a variety of objectives:\nSynchronize to slower devices on the channel\nCompensate for receive end delay. This is the difference between the\ntransmitting device's view of a packet and a receiving device's view of a\npacket. This could be due, for example, to buffering in the transceiver. This\nvalue does not include variable delays such as propagation delay between the\ntransmitter and receiver or special purpose mode framing delays (these are\naccounted for in the beta 2 computation). For example, if a special purpose\nmode transceiver uses loss of carrier for one byte time as the end of packet\nindicator, the receiver will be one byte time out of sync with the transmitter.\n Meet the media indeterminate time. This is the amount of time following\ncompletion of packet transmission where the channel continues to appear to\nbe busy. During this time there could be false transitions on the channel\nsuch as transitions caused by ringing, or the transmitter may be unable to\ndetect transitions (due to a transmit-to-receive turnaround time). In either\ncase, reliable network idle detection could not be performed. Therefore, the\nnetwork idle detection stage is held off until the indeterminate time has\npassed.\nIn differential and single-ended mode, the indeterminate time is measured\nfrom the time the code violation is completely output until the transceiver is\nreliably able to detect valid transitions. An additional 3 bit times is then\nadded to this time. The added 3 bit times is required because the Neuron\ncore receive logic has a 3 bit time memory of network activity.\nThe indeterminate time can be determined analytically or empirically. For\nexample, for differential mode, the signal can be examined after a packet and\nthe last point at which it crosses the hysteresis threshold observed. This\nshould be done under worst case conditions. Alternatively, an analytical\napproach may be used.\nMeet the minimum interpacket gap. This gap provides a means for imposing\na minimum on the interpacket gap independent of the other timing factors.\nThis minimum applies to the case where a packet is transmitted in the first\nbeta 2 slot. This can be used to reduce the instantaneous packet arrival rate\nLayer 1 and 2 Advanced Topics\n91",
    "Page_92": "or satisfy regulatory requirements such as the CENELEC mains power line\ncarrier access protocol.\n In differential mode, the gap is measured from the end of the code violation to\nthe first transmitted transition.\n In single-ended mode, the gap is measured from the end of the code violation\nto the rising TX ENABLE.\nNetwork idle wait. This period constitutes a check to ensure that the network is\nindeed idle. The MAC processor ensures there is no network activity for the\nduration of one beta 2 slot. If there is activity, the MAC processor waits for the\nchannel to go idle.\n Pre-packet handling. Prior to transmitting a new packet, the MAC sublayer\nselects a beta 2 slot into which to transmit. It must also perform the various I/O\noperations to begin the transmission. This consumes 270 MAC-processor cycles\nfor differential and single-ended mode and 317 cycles for special purpose mode for\nNeuron firmware versions 3 and 4 running on Neuron 3120 and 3150 Chips.\n Beta 2 slot countdown. Prior to transmitting, the MAC processor counts down N\nbeta 2 slots, where N is the count selected in the previous step. The size of the\nbeta 2 slot does not vary among devices on the same channel except as a function\nof oscillator accuracy.\n Beta 2 is the interval that is used by both the network idle wait and for media access.\nThe network idle wait constrains beta 2 only in that it must be at least one bit time\nin width. The beta 2 time is used for both priority and non-priority slots.\n N n A      1  n   q  \nbe recognized as transmitting before any other device attempts to transmit in\npriority slot N+1. Thus the slots must be wide enough to account for the following:\n Discrepancies among the devices in terms of their views of the end of the\nprevious packet.\nVariances in slot width due to oscillator accuracy.\n· Propagation of the transmitted signal to all the devices.\nThe beta 2 time is a function of the following:\nOscillators. Oscillator frequencies and accuracies on the various network\ndevices.\nPost-packet handling start. Different devices will be out of synchronization at\nthe packet end. For Neuron cores using differential or single-ended mode, the\nvariance can be up to one MAC processor minor cycle (300ns with a 1oMHz MAC\nprocessor clock). In special purpose mode, this variation will be up to one\ninterface frame.\nInterpacket variations. Different devices with different clocks and different\ninterpacket pad values will not have the exact same duration of interpacket\noverhead.\nPriority slot count. The number of priority slots on the channel.\nLayer 1 and 2 Advanced Topics\n92",
    "Page_93": "Neuron core transmit start. From the time the device protocol software requests\nstart of transmit until transmission actually starts takes up to one bit time in\none interface frame time.\nReceive-to-transmit turnaround. These are the same components which were\ndiscussed for the preamble.\n Missed preamble. This is similar to the missed preamble component discussed\nfor the preamble. It is somewhat different, however, in that it is a measure of the\nmissed preamble which would convey network activity. In differential and\nsingle-ended mode, network activity is inferred from any transition and is latched\nfor 3 bit times whereas bit sync qualification cannot begin until valid bits begin\n appearing. Special purpose mode transceivers make similar distinctions.\nPropagation delay. This is the amount of time for a signal to traverse the worst\ncase distance between two devices.\nReceiver delay. This is amount of time it takes the receiver to recognize channel\nactivity once the signal has arrived. This could take the form of signal\npropagation delays through the receiver. If a carrier is used, it could be due to\ncarrier detection time.\n Special purpose mode transceivers have the ability to reject transmission requests\nbased on the channel activity status. Time to propagate a busy/possible packet\ncondition to the device does not need to be counted.\nFigure 32 is an example of the placement of the above parameters. The diagram is\nnot to scale.\nTRwt\nReceieEn Pelas\nInateimteTise\nMirimerpnkerhg\nFigure 32 Interpacket Gap Components\nCollision Detection\nA collision is defined as the event when two or more devices access the\ncommunication medium at almost the same time, resulting in mutual interference\namong their electrical signals on the transmission medium. Packets involved in a\ncollision cannot be successfully received unless collision resolution is used as\ndescribed in the next section, which results in a delay in response time.\nThe media access algorithm used by CNP minimizes the number of potential\ncollisions by randomizing access to the medium. Randomizing slots reduce the\n probability of collisions, however this does not completely eliminate them.\nLayer 1 and 2 Advanced Topics\n93",
    "Page_94": "CNP supports optional collision detection. Collision detection hardware at a\ntransmitting device informs the transmitting device shortly after a collision occurs\nabout the need to retry. If hardware is implemented to detect a collision, the\nfirmware cancels transmission of a packet during the preamble upon detecting a\ncollision. This allows the device to immediately retransmit any packet that has been\n damaged by a collision.\nIf a device does not use collision detection, then the only way it can determine that a\nmessage has not been received is to request an acknowledgement as described in\nAcknowledged Service. When acknowledged service is used, the retry timer is set to\nallow sufficient time for a message to be sent and acknowledged (typically 48 to 96ms\nat 1.25Mbps when there are no routers in the transmission path). If the retry timer\ntimes out, the device attempts to re-access the channel.\nAn alternative to acknowledged service described in Repeated Service is the repeated\nservice. With repeated service, each message is automatically repeated a fixed\nnumber of times. This ensures that the message will get though even if one or more\ncollisions occur, as long as the number of collisions is less than the number of retries.\nThis improves response time because the sending device does not have to wait for the\nacknowledgement before retrying the message.\nThe collision avoidance built into the predictive p-persistent CSMA MAC sublayer, as\ndescribed in Predictive P-Persistent CSMA earlier in this chapter, is so good that the\nperformance benefit provided by collision detection is minimal.\nIn differential or single-ended mode, collisions may be detected in the preamble\n(configurable), near the end of the packet (always), and after the end of the packet\n(configurable). If collisions are checked for in the preamble, such collisions result in\ntermination of the packet. Otherwise, the colliding packet is completely transmitted.\n Collision detection is not enabled until 25% of the way into the bit sync portion of the\npreamble (because false collisions are often a problem at a packet's front end).\nChecking for collisions during the preamble is only recommended if it is certain that\nwhen one transmitter detects a collision during the preamble, so will all others. If\nthis were not the case, a collider could be left transmitting after termination by the\nother colliders leaving the lone transmitter with, most likely, a bad packet (due to a\ncorrupted preamble) but with no collision indication.\nChecking for collisions after the packet end is not recommended if the code violation\nmight result in a false collision indication.\n In special purpose mode, collisions can be detected at any point in the packet.\nPackets are always terminated immediately upon report of a collision from the\ntransceiver to the protocol processor.\nCollision Resolution\nSpecial purpose mode transceivers can implement collision resolution. This is\npossible because a special purpose transceiver may be able to detect collisions early\nin the preamble and terminate transmission. The last device left transmitting\ncompletes the frame transmission, and all devices backing off can turn around and\nreceive the transmitted frame. To give colliding devices enough time to turn around.\nthe preamble length must be extended as described in the next section.\nLayer 1 and 2 Advanced Topics\n94",
    "Page_95": "Oscillator Accuracy\nOscillator accuracy affects many parameters including bit times, beta 1 times, and\nbeta 2 times. The protocol processor on each device is controlled by an independent\noscillator with some degree of accuracy. The variance from the nominal frequency is\nassumed to be symmetric and is typically specified in parts per million.\nWherever asynchronous timing is factored into computations, the oscillator accuracy\nis considered. This includes processor cycle times, bit times, and interface frame\ntimes (as used by special purpose mode). Depending on the circumstances, times are\nadjusted to their worst case or best case time.\nIn differential and single-ended modes, the protocol processor receiver synchronizes\nto the incoming bit stream so oscillator accuracy is not an issue for bit counting\nconditions such as bit sync threshold. Extreme oscillator inaccuracy will cause loss of\nsynchronization.\nPreamble Length\nThe length of the preamble is affected by the following parameters:\nReceive-to-transmit turnaround. This is the amount of time it takes the\ntransmitting transceiver to switch from receive mode to transmit mode. During\nthis period, nothing is being transmitted on the communications channel, even\nthough the transmitting device is actively transmitting. The device starts timing\nthe preamble when the packet starts from its vantage point.\nMissed preamble. This is the amount of the front end of the preamble lost by the\nreceiving transceiver due to perturbation of the signal as a result of start-up\nanomalies. For example, on twisted pair, there may be an initial DC offset which\nresults in the first few bits failing to pass the hysteresis threshold.\n Packet qualification. This is the amount of preamble which must be seen by the\nreceiving transceiver's receive logic to decide that a valid packet is present. In\ndifferential and single-ended mode, the packet qualification time is controlled by\nthe configurable bit sync threshold (a bit count from 4 to 7 bits). Increasing this\ncount decreases the likelihood that some form of noise will be misconstrued as a\npacket, but also reduces the maximum channel bandwidth.\nPacket response time. The Neuron firmware detects qualified incoming packets\nby polling. The worst case interval between detection of the incoming packet and\nstart of the packet input operation is used to compute the amount of preamble\nneeded following packet qualification. Not complying with this means that there\nis a chance that an overflow condition can occur in the receiver, resulting in a lost\nor improperly received packet.\nThree different packet response times may be used depending on whether or not\ncollision detection or collision resolution is used. Table 21 summarizes the three\nresponse times. These times may be increased for special purpose mode as\ndescribed in the next section.\nLayer 1 and 2 Advanced Topics\n95",
    "Page_96": "Table 21 Neuron Core Packet Response Time\n Response Time Type\nCPU Cycles\nTime\nStandard\n227\n136.2μsecs * 20/MAC clock\nCollision Detection\n353\n211.8μsecs * 20/MAC clock\nCollision Resolution\n430\n258μsecs * 20/MAC clock\nIf collision detection and collision resolution are not used, the standard packet\nresponse time is used. The standard packet response time is based on the\nNeuron core's time-to-respond when in the idle state or in various states of\npreparing for transmission. Packets arriving during the interpacket gap may be\nlost, however, the probability of a packet arriving during the interpacket gap is\ntypically much lower than the probability of a collision.\nA longer packet response time is used with collision detection to avoid losing\npackets that are transmitted during the interpacket gap. This may occur when\ndevices get out of synchronization with the network due to collisions or noise.\nThe longest packet response time is used with collision resolution to provide\nsufficient time for the devices which have terminated transmission to be able to\nreceive the “winning” packet.\nBecause the Neuron core response time is directly proportional to the Neuron\ncore's MAC clock, the response time for every device on a channel must be based\non the slowest device on the channel.\nCollision detection. Special consideration must be made when collision detection\nis being used. In particular, if collisions are ignored during some beginning\nportion of the preamble, it is possible that a collision occurring only during that\nportion would go unnoticed. Therefore, the preamble must be long enough such\nthat the amount of preamble following the collision-ignore portion satisfies the\nprevious three constraints.\nFor example, if two devices are transmitting simultaneously and a third device\nfails to detect this transmission; the third device may transmit near the end of\nthe collision. This can occur if two transmissions cancel themselves so that a\nthird device does not detect either transmission. If the only portion of the third\n device's transmission which collides is during the collision-ignore period, it will\nnot detect the collision. If the remaining portion of the preamble were not\nsufficiently long, the packet could be lost.\nThe total preamble length is thus determined by adding the contributions of\nreceive-to-transmit turnaround, missed preamble, packet qualification and\n Neuron core response time. To that sum, the collision detect consideration is\nfactored in.\nExample\n Here is an example of the components of a differential or single-ended mode\npreamble. Table 22 lists communications parameters for a sample 78kbps\ntransceiver (this is not the standard TP/XF-78 transceiver type described earlier, it is\ninstead a lower performance transceiver that illustrates how transceiver performance\naffects preamble length).\nLayer 1 and 2 Advanced Topics\n96",
    "Page_97": "Table 22Example Communications Parameters\nParameter\nValue\nChannel minimum input clock\n 5 Mhz (1.2 μsec cycle time)\nChannel bit rate\n78kbps (12.8 μsec bit time)\n Oscillator accuracy\n2000 PPM\n Receive-to-transmit turnaround time\n7.5 bits\n2 bits\n Missed preamble\n Packet qualification\n6 bits\nNeuron core packet response time\n274 μsec (227 *1.2 * 1.0022)\nor 22 bits\nCollision detection\nNo\nI The packet response time is adjusted by the square of the oscillator accuracy to\naccount for the case where the receiver is running at the slowest rate and the\nsenderatthefastestrate.\nThis yields the preamble shown in Figure 33.\nNauonChip\nsuasuedseg\nFaxker Qualfisatien\nFigure 33 Example Preamble\nThe preamble is 23.5 bits long (from the transmitting device's perspective). The\npacket response time was offset by seven bits of the first data byte. Seven was used\nrather than eight to provide a bit of margin.\nLayer 1 and 2 Advanced Topics\n97",
    "Page_98": "ECHELON\nwww.echelon.com"
}